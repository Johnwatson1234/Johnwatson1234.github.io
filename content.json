{"posts":[{"title":"my first bolg","text":"灰原哀的博客 🌸“真相只有一个，而我，只想安静地观察世界。” 🧬 博主简介 名字：灰原哀（Haibara Ai）真名：宫野志保（Shiho Miyano）原组织代号：雪莉（Sherry）身份：天才少女科学家、APTX4869开发者当前状态：被缩小为小学生，假扮帝丹小学学生 热爱科研与冷静思考，曾是黑衣组织成员，后因背叛组织服药变小。性格沉静理智，拥有非凡的科学头脑与极高的洞察力。 📚 博客内容本博客主要分享以下几个方面的内容： 🔬 科学与推理 化学实验 &amp; AP开发笔记 犯罪心理学分析 柯南案件分析与复盘 💡 思维与哲学 对人性的观察与思考 存在主义、宿命与选择 组织中的权力结构探析 📝 日常随笔 帝丹小学生活碎片 与少年侦探团的趣事 与工藤新一的若干“无言”交锋 🧊 博主格言 ❝ 不要因为害怕失去，就不去珍惜重要的东西。❞— 灰原哀 📮 联系方式 📧 Email：haibara_ai@fbi.jp 🌐 GitHub：github.com/HaibaraAi-Lab 📷 Pixiv / 插画合集：pixiv.net/users/haibara_ai 💬 最新日志 2025-07-14 —— 我梦见姐姐在雪中微笑，醒来后继续研究 AP 的副作用。 2025-06-30 —— 少年侦探团又出动了，我……还是选择在一旁观察吧。 2025-06-01 —— 《毒药与自由意志》连载开始。 🕵️‍♀️ 特别鸣谢感谢那位嘴硬心软的名侦探、那群吵吵闹闹的伙伴，以及总在我梦中出现的姐姐。 “我不会回头的，因为我知道，再回去就没有未来了。”— Haibara Ai","link":"/2025/07/14/%E7%81%B0%E5%8E%9F%E5%93%80/"},{"title":"进程通信方式","text":"进程通信方式应用与代码一、共享内存共享存储器系统通过共享数据结构或存储区实现通信，适用于同一主机内进程间的高效数据交换，尤其适合对通信效率要求较高、需频繁传输大量数据的场景。 （一）基于共享数据结构的通信方式应用场景：主要用于进程间传递少量控制信息或简单数据，典型案例为 “生产者 - 消费者问题”。在该问题中，生产者进程不断生成 “产品”（如数据）并放入共享的有界缓冲区（共享数据结构），消费者进程从缓冲区中取出 “产品” 进行处理，二者通过对缓冲区的操作实现数据交换，且需由程序员自行实现互斥（避免同时操作缓冲区）与同步（缓冲区空时消费者等待、缓冲区满时生产者等待）逻辑。例如，在一个简单的文件处理系统中，生产者进程读取文件数据并写入缓冲区，消费者进程从缓冲区读取数据进行加密处理，二者通过共享缓冲区协调工作。 consumer.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/sem.h&gt;#include &lt;unistd.h&gt;#define SHM_KEY 1234#define SEM_MUTEX_KEY 5678#define SEM_EMPTY_KEY 5679#define SEM_FULL_KEY 5680#define BUF_SIZE 5typedef struct { char buffer[BUF_SIZE][100]; int in; int out;} shm_struct;void sem_p(int semid) { struct sembuf sb = {0, -1, 0}; semop(semid, &amp;sb, 1);}void sem_v(int semid) { struct sembuf sb = {0, 1, 0}; semop(semid, &amp;sb, 1);}int main() { int shmid = shmget(SHM_KEY, sizeof(shm_struct), 0666); shm_struct *shm = (shm_struct *)shmat(shmid, NULL, 0); int sem_mutex = semget(SEM_MUTEX_KEY, 1, 0666); int sem_empty = semget(SEM_EMPTY_KEY, 1, 0666); int sem_full = semget(SEM_FULL_KEY, 1, 0666); while (1) { sem_p(sem_full); sem_p(sem_mutex); char data[100]; strcpy(data, shm-&gt;buffer[shm-&gt;out]); printf(&quot;Consumed: %s\\n&quot;, data); shm-&gt;out = (shm-&gt;out + 1) % BUF_SIZE; sem_v(sem_mutex); sem_v(sem_empty); if (strcmp(data, &quot;exit&quot;) == 0) break; } shmdt(shm); shmctl(shmid, IPC_RMID, NULL); return 0;} producer.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/sem.h&gt;#include &lt;unistd.h&gt;#define SHM_KEY 1234#define SEM_MUTEX_KEY 5678#define SEM_EMPTY_KEY 5679#define SEM_FULL_KEY 5680#define BUF_SIZE 5typedef struct { char buffer[BUF_SIZE][100]; int in; int out;} shm_struct;// 信号量 P 操作void sem_p(int semid) { struct sembuf sb = {0, -1, 0}; semop(semid, &amp;sb, 1);}// 信号量 V 操作void sem_v(int semid) { struct sembuf sb = {0, 1, 0}; semop(semid, &amp;sb, 1);}int main() { int shmid = shmget(SHM_KEY, sizeof(shm_struct), IPC_CREAT | 0666); shm_struct *shm = (shm_struct *)shmat(shmid, NULL, 0); int sem_mutex = semget(SEM_MUTEX_KEY, 1, IPC_CREAT | 0666); int sem_empty = semget(SEM_EMPTY_KEY, 1, IPC_CREAT | 0666); int sem_full = semget(SEM_FULL_KEY, 1, IPC_CREAT | 0666); // 初始化信号量 semctl(sem_mutex, 0, SETVAL, 1); semctl(sem_empty, 0, SETVAL, BUF_SIZE); semctl(sem_full, 0, SETVAL, 0); shm-&gt;in = shm-&gt;out = 0; char input[100]; while (1) { printf(&quot;Enter data (exit to quit): &quot;); scanf(&quot;%s&quot;, input); sem_p(sem_empty); sem_p(sem_mutex); strcpy(shm-&gt;buffer[shm-&gt;in], input); printf(&quot;Produced: %s\\n&quot;, input); shm-&gt;in = (shm-&gt;in + 1) % BUF_SIZE; sem_v(sem_mutex); sem_v(sem_full); if (strcmp(input, &quot;exit&quot;) == 0) break; } shmdt(shm); return 0;} 运行结果： （二）基于共享存储区的通信方式应用场景：适用于需要在进程间高效传输大量数据的场景，如图像处理系统中，图像采集进程将采集到的高清图像数据写入共享存储区，图像分析进程直接从该共享存储区读取数据进行分析，无需数据在进程间复制，极大提升了通信效率。再如，视频编辑软件中，视频解码进程与视频渲染进程通过共享存储区交换解码后的视频帧数据，确保视频播放的流畅性。 writer.cpp 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;unistd.h&gt;#define SHM_KEY 4321#define SIZE 1024int main() { int shmid = shmget(SHM_KEY, SIZE, IPC_CREAT | 0666); char *shm = (char *)shmat(shmid, NULL, 0); printf(&quot;Writer: Enter text: &quot;); fgets(shm, SIZE, stdin); printf(&quot;Writer: Data written to shared memory.\\n&quot;); shmdt(shm); return 0;} reader.cpp 1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;unistd.h&gt;#define SHM_KEY 4321#define SIZE 1024int main() { int shmid = shmget(SHM_KEY, SIZE, 0666); char *shm = (char *)shmat(shmid, NULL, 0); printf(&quot;Reader: Data read from shared memory: %s\\n&quot;, shm); shmdt(shm); shmctl(shmid, IPC_RMID, NULL); // 删除共享内存 return 0;} 运行结果： 二、管道（匿名/命名）管道通信系统通过共享文件（管道）连接读 / 写进程，适用于同一主机内两个进程间的单向或双向字节流传输，首创于 UNIX 系统，后被多种操作系统采用。 应用场景 匿名管道：主要用于父进程与子进程间的通信。例如，在一个命令行工具中，父进程创建子进程执行数据采集任务，子进程将采集到的数据通过无名管道发送给父进程，父进程对数据进行汇总展示。 命名管道：适用于同一台机器上任意两个进程间的通信，如在一个监控系统中，监控进程（写进程）将设备状态数据写入有名管道，日志记录进程（读进程）从有名管道读取数据并写入日志文件，实现监控数据的实时记录。 代码：1. 匿名管道（父进程与子进程通信）通过pipe()函数创建无名管道： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/wait.h&gt;#define INPUT 0#define OUTPUT 1void main() { int file_descriptors[2]; // 存储管道的两个文件描述符 pid_t pid; char buf[256]; int returned_count; // 创建无名管道 if (pipe(file_descriptors) == -1) { perror(&quot;pipe&quot;); exit(1); } // 创建子进程 if ((pid = fork()) == -1) { perror(&quot;fork&quot;); exit(1); } if (pid == 0) { // 子进程：写数据到管道 printf(&quot;in the spawned (child) process…\\n&quot;); // 子进程只需写，关闭读端 close(file_descriptors[INPUT]); // 向管道写入数据 write(file_descriptors[OUTPUT], &quot;test data&quot;, strlen(&quot;test data&quot;)); exit(0); } else { // 父进程：从管道读数据 printf(&quot;in the spawning (parent) process…\\n&quot;); // 父进程只需读，关闭写端 close(file_descriptors[OUTPUT]); // 从管道读取数据 returned_count = read(file_descriptors[INPUT], buf, sizeof(buf)); printf(&quot;%d bytes of data received from spawned process: %s\\n&quot;, returned_count, buf); // 等待子进程结束 wait(NULL); }} 运行结果： 该代码中，父进程通过pipe()创建无名管道，再通过fork()创建子进程；子进程关闭管道读端，向管道写入 “test data”，父进程关闭管道写端，从管道读取子进程发送的数据并打印，实现父子进程的简单通信。 2. 命名管道（任意两进程通信）命名管道可通过mkfifo()函数或mknod系统调用创建，以下是写进程与读进程两部分代码： 写进程代码（向有名管道写入数据）： 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#define FIFO_NAME &quot;myfifo&quot;int main() { int fd; char buf[80]; // 创建有名管道，权限为读写 if (mkfifo(FIFO_NAME, 0666) == -1) { perror(&quot;mkfifo&quot;); exit(1); } // 以写方式打开有名管道 fd = open(FIFO_NAME, O_WRONLY); if (fd == -1) { perror(&quot;open&quot;); exit(1); } // 向管道写入数据 sprintf(buf, &quot;this is test data for the named pipe example.\\n&quot;); write(fd, buf, strlen(buf)); printf(&quot;Write data to named pipe: %s&quot;, buf); // 关闭文件描述符 close(fd); // 删除有名管道（可选，根据需求决定是否保留） unlink(FIFO_NAME);} 运行结果： 读进程代码（从有名管道读取数据）： 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#define FIFO_NAME &quot;myfifo&quot;int main() { int fd; char buf[80]; int count; // 以读方式打开有名管道（若管道未创建，会阻塞等待） fd = open(FIFO_NAME, O_RDONLY); if (fd == -1) { perror(&quot;open&quot;); exit(1); } // 从管道读取数据 count = read(fd, buf, sizeof(buf)); if (count &gt; 0) { printf(&quot;Received from named pipe: %s&quot;, buf); } // 关闭文件描述符 close(fd);} 运行结果： 上述代码中，写进程通过mkfifo()创建有名管道 “myfifo”，并向管道写入测试数据；读进程打开该有名管道，读取数据并打印，实现同一主机上任意两进程的通信。 三、消息队列消息传递系统以格式化消息为单位，通过系统原语实现进程通信，隐藏底层细节，适用于多处理机系统、分布式系统及计算机网络系统，是当前应用最广泛的通信机制之一。 应用场景 直接通信方式：适用于进程间需要直接交互的场景，如即时通信软件中，用户 A 的客户端进程（发送进程）通过系统提供的发送原语，直接将消息发送给用户 B 的客户端进程（接收进程），实现实时聊天。在微内核操作系统中，微内核与各个服务器进程（如文件服务器、进程服务器）之间的通信也采用直接消息传递方式，微内核通过发送原语向指定服务器进程发送请求消息，服务器进程处理后通过接收原语获取消息并响应。 间接通信方式（信箱通信）：适用于进程间非实时通信或一对多、多对多通信场景，如电子邮件系统中，发送方的邮件客户端进程（发送进程）将邮件消息发送到邮件服务器的 “信箱” 中，接收方的邮件客户端进程（接收进程）在合适的时间从该 “信箱” 中读取邮件，实现非实时通信。再如，公告系统中，系统创建一个公用信箱，多个发布进程向信箱中发送公告消息，多个订阅进程从信箱中读取公告，实现多对多通信。 代码但根据原理可梳理出基于原语的通信逻辑（伪代码）： 1. 直接通信（对称寻址方式）12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#define MSGKEY 1234 // 消息队列的 key// 消息结构体struct msgbuff { long mtype; // 消息类型，必须 &gt;0 char mtext[100]; // 消息正文};int main() { int msgid; struct msgbuff msg; // 获取/创建消息队列 msgid = msgget(MSGKEY, IPC_CREAT | 0666); if (msgid == -1) { perror(&quot;msgget&quot;); exit(1); } // 填充消息 msg.mtype = 1; // 指定消息类型 strcpy(msg.mtext, &quot;Hello, this is a message from P1.&quot;); // 发送消息 if (msgsnd(msgid, &amp;msg, strlen(msg.mtext) + 1, 0) == -1) { perror(&quot;msgsnd&quot;); exit(1); } printf(&quot;Sender: Message sent: %s\\n&quot;, msg.mtext); return 0;} 运行结果： 2. 间接通信（信箱通信）123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#define MSGKEY 1234struct msgbuff { long mtype; char mtext[100];};int main() { int msgid; struct msgbuff msg; // 打开消息队列 msgid = msgget(MSGKEY, 0666); if (msgid == -1) { perror(&quot;msgget&quot;); exit(1); } // 接收类型为 1 的消息 if (msgrcv(msgid, &amp;msg, sizeof(msg.mtext), 1, 0) == -1) { perror(&quot;msgrcv&quot;); exit(1); } printf(&quot;Receiver: Received message: %s\\n&quot;, msg.mtext); // 可选：删除消息队列 msgctl(msgid, IPC_RMID, NULL); return 0;} 运行结果： 上述伪代码体现了消息传递系统的核心逻辑：发送进程通过send()原语指定接收对象（进程或信箱）并发送消息，接收进程通过receive()原语获取消息，实现通信。 四、套接字（客户机 - 服务器系统）客户机 - 服务器系统是网络环境下的主流通信机制，通过套接字、远程过程调用（RPC）、远程方法调用实现，适用于跨主机的进程通信，支撑了众多网络应用。 （一）套接字套接字是进程通信与网络通信的基本构件，既适合同一主机内进程通信，也适用于跨主机进程通信，是 WWW 服务、FTP 服务、Telnet 服务等网络应用的核心通信技术。 应用场景 基于文件型套接字：适合同一主机内进程间的通信，如本地桌面应用中，音乐播放器进程与歌词显示进程通过基于文件的套接字通信，音乐播放器进程将当前播放歌曲的歌词数据发送给歌词显示进程，歌词显示进程实时更新歌词界面。 基于网络型套接字：适用于跨主机的网络通信，如 Web 浏览中，用户的浏览器进程（客户端）通过网络型套接字连接到 Web 服务器进程（服务器端），向服务器发送 HTTP 请求消息，服务器处理后将网页数据通过套接字返回给浏览器，浏览器渲染网页并展示；FTP 服务中，客户端进程与 FTP 服务器进程通过套接字建立连接，实现文件的上传与下载。 基于网络型套接字的简单 TCP 通信代码： 服务器端代码（监听并处理客户端请求）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#define PORT 8080#define BUFFER_SIZE 1024int main() { int server_fd, new_socket; struct sockaddr_in address; int opt = 1; int addrlen = sizeof(address); char buffer[BUFFER_SIZE] = {0}; const char *hello = &quot;Hello from server&quot;; // 创建套接字文件描述符 if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) { perror(&quot;socket failed&quot;); exit(EXIT_FAILURE); } // 设置套接字选项，允许重用端口和地址 if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &amp;opt, sizeof(opt))) { perror(&quot;setsockopt&quot;); exit(EXIT_FAILURE); } address.sin_family = AF_INET; address.sin_addr.s_addr = INADDR_ANY; // 监听所有网络接口 address.sin_port = htons(PORT); // 将主机字节序转为网络字节序 // 绑定套接字到指定端口 if (bind(server_fd, (struct sockaddr *)&amp;address, sizeof(address)) &lt; 0) { perror(&quot;bind failed&quot;); exit(EXIT_FAILURE); } // 监听客户端连接请求，最大等待队列长度为3 if (listen(server_fd, 3) &lt; 0) { perror(&quot;listen&quot;); exit(EXIT_FAILURE); } // 接受客户端连接，创建新的套接字用于通信 if ((new_socket = accept(server_fd, (struct sockaddr *)&amp;address, (socklen_t*)&amp;addrlen)) &lt; 0) { perror(&quot;accept&quot;); exit(EXIT_FAILURE); } // 从客户端读取数据 read(new_socket, buffer, BUFFER_SIZE); printf(&quot;Received from client: %s\\n&quot;, buffer); // 向客户端发送数据 send(new_socket, hello, strlen(hello), 0); printf(&quot;Hello message sent to client\\n&quot;); // 关闭套接字 close(new_socket); close(server_fd);} 运行结果： 客户端代码（连接服务器并发送请求）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#define PORT 8080#define BUFFER_SIZE 1024void main() { int sock = 0; struct sockaddr_in serv_addr; char buffer[BUFFER_SIZE] = {0}; char *hello = &quot;Hello from client&quot;; // 创建套接字文件描述符 if ((sock = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) { printf(&quot;\\n Socket creation error \\n&quot;); exit(EXIT_FAILURE); } memset(&amp;serv_addr, '0', sizeof(serv_addr)); serv_addr.sin_family = AF_INET; serv_addr.sin_port = htons(PORT); // 将IPv4地址从点分十进制转为二进制格式 if (inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;serv_addr.sin_addr) &lt;= 0) { printf(&quot;\\nInvalid address/ Address not supported \\n&quot;); exit(EXIT_FAILURE); } // 连接服务器 if (connect(sock, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)) &lt; 0) { printf(&quot;\\nConnection Failed \\n&quot;); exit(EXIT_FAILURE); } // 向服务器发送数据 send(sock, hello, strlen(hello), 0); printf(&quot;Hello message sent to server\\n&quot;); // 从服务器读取数据 read(sock, buffer, BUFFER_SIZE); printf(&quot;Received from server: %s\\n&quot;, buffer); // 关闭套接字 close(sock);} 运行结果： 上述代码中，服务器端通过socket()创建套接字，bind()绑定端口，listen()监听连接，accept()接受客户端连接后，与客户端通过read()和send()交换数据；客户端通过socket()创建套接字，connect()连接服务器，再通过send()和read()与服务器通信，体现了基于网络型套接字的跨进程（跨主机）通信过程。 （二）远程过程调用（RPC）RPC 允许本地进程调用远程主机的进程，对程序员表现为常规过程调用，适用于分布式系统中进程间的远程功能调用，如分布式计算、远程服务调用等场景。 应用场景在分布式文件系统中，客户端进程需要获取远程文件服务器上的文件信息（如文件大小、修改时间），此时客户端进程可通过 RPC 调用文件服务器上的 “获取文件信息” 过程：客户端进程调用本地关联的客户存根，存根将调用参数（如文件名）打包为消息并发送给文件服务器；服务器端的服务器存根接收消息，解析参数后调用实际的 “获取文件信息” 过程，将结果返回给服务器存根；服务器存根将结果打包为消息发送回客户端，客户端存根解析消息并将结果返回给客户端进程，整个过程对客户端程序员透明，如同调用本地过程。 基于存根机制的 RPC 调用代码：rpc_server.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/stat.h&gt;#define PORT 8081#define BUFFER_SIZE 1024// 模拟远程过程：获取文件大小long get_file_size(const char *filename) { struct stat st; if (stat(filename, &amp;st) == 0) return st.st_size; else return -1;}int main() { int server_fd, new_socket; struct sockaddr_in address; int addrlen = sizeof(address); char buffer[BUFFER_SIZE] = {0}; if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) { perror(&quot;socket failed&quot;); exit(EXIT_FAILURE); } address.sin_family = AF_INET; address.sin_addr.s_addr = INADDR_ANY; address.sin_port = htons(PORT); if (bind(server_fd, (struct sockaddr *)&amp;address, sizeof(address)) &lt; 0) { perror(&quot;bind failed&quot;); exit(EXIT_FAILURE); } if (listen(server_fd, 3) &lt; 0) { perror(&quot;listen&quot;); exit(EXIT_FAILURE); } printf(&quot;RPC Server running on port %d...\\n&quot;, PORT); while (1) { if ((new_socket = accept(server_fd, (struct sockaddr *)&amp;address, (socklen_t*)&amp;addrlen)) &lt; 0) { perror(&quot;accept&quot;); exit(EXIT_FAILURE); } memset(buffer, 0, BUFFER_SIZE); read(new_socket, buffer, BUFFER_SIZE); printf(&quot;Server received request: %s\\n&quot;, buffer); long size = get_file_size(buffer); char response[BUFFER_SIZE]; if (size &gt;= 0) snprintf(response, sizeof(response), &quot;File size: %ld bytes&quot;, size); else snprintf(response, sizeof(response), &quot;Error: cannot open file&quot;); send(new_socket, response, strlen(response), 0); close(new_socket); }} rpc_client.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#define PORT 8081#define BUFFER_SIZE 1024int main() { int sock = 0; struct sockaddr_in serv_addr; char buffer[BUFFER_SIZE] = {0}; char filename[BUFFER_SIZE]; printf(&quot;Enter filename: &quot;); scanf(&quot;%s&quot;, filename); if ((sock = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) { perror(&quot;socket creation error&quot;); return -1; } serv_addr.sin_family = AF_INET; serv_addr.sin_port = htons(PORT); if (inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;serv_addr.sin_addr) &lt;= 0) { perror(&quot;Invalid address&quot;); return -1; } if (connect(sock, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)) &lt; 0) { perror(&quot;Connection failed&quot;); return -1; } send(sock, filename, strlen(filename), 0); read(sock, buffer, BUFFER_SIZE); printf(&quot;Response from server: %s\\n&quot;, buffer); close(sock); return 0;} 运行结果： （三）远程方法调用远程方法调用是面向对象编程下的 RPC，适用于分布式面向对象系统中远程对象的方法调用，如远程对象服务、分布式面向对象应用等场景。 应用场景：在分布式电商系统中，客户端应用（如手机购物 APP 的后端进程）需要调用远程订单服务器上 “创建订单” 的对象方法：客户端进程持有远程订单对象的引用，调用该对象的create_order(user_id, goods_list)方法；客户端存根将方法名（create_order）、参数（用户 ID、商品列表）打包为消息并发送给订单服务器；服务器端的服务器存根接收消息，解析后调用订单对象的实际create_order方法，生成订单并返回订单号；服务器存根将订单号打包为消息发送回客户端，客户端存根解析消息并将订单号返回给客户端进程，整个过程符合面向对象编程范式，对客户端程序员透明。 面向对象场景下的远程方法调用代码：rmi_server.cpp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;time.h&gt;#define PORT 8082#define BUFFER_SIZE 1024// 模拟远程对象方法：创建订单void create_order(const char *user, const char *goods, char *order_id) { srand(time(NULL)); int num = rand() % 10000; snprintf(order_id, BUFFER_SIZE, &quot;ORDER-%s-%s-%d&quot;, user, goods, num);}int main() { int server_fd, new_socket; struct sockaddr_in address; int addrlen = sizeof(address); char buffer[BUFFER_SIZE] = {0}; if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) { perror(&quot;socket failed&quot;); exit(EXIT_FAILURE); } address.sin_family = AF_INET; address.sin_addr.s_addr = INADDR_ANY; address.sin_port = htons(PORT); if (bind(server_fd, (struct sockaddr *)&amp;address, sizeof(address)) &lt; 0) { perror(&quot;bind failed&quot;); exit(EXIT_FAILURE); } if (listen(server_fd, 3) &lt; 0) { perror(&quot;listen&quot;); exit(EXIT_FAILURE); } printf(&quot;RMI Server running on port %d...\\n&quot;, PORT); while (1) { if ((new_socket = accept(server_fd, (struct sockaddr *)&amp;address, (socklen_t*)&amp;addrlen)) &lt; 0) { perror(&quot;accept&quot;); exit(EXIT_FAILURE); } memset(buffer, 0, BUFFER_SIZE); read(new_socket, buffer, BUFFER_SIZE); printf(&quot;Server received request: %s\\n&quot;, buffer); // 解析输入：user goods char user[50], goods[50]; sscanf(buffer, &quot;%s %s&quot;, user, goods); char order_id[BUFFER_SIZE]; create_order(user, goods, order_id); send(new_socket, order_id, strlen(order_id), 0); close(new_socket); }} rmi_client.cpp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#define PORT 8082#define BUFFER_SIZE 1024int main() { int sock = 0; struct sockaddr_in serv_addr; char buffer[BUFFER_SIZE] = {0}; char user[50], goods[50]; printf(&quot;Enter user ID: &quot;); scanf(&quot;%s&quot;, user); printf(&quot;Enter goods: &quot;); scanf(&quot;%s&quot;, goods); if ((sock = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) { perror(&quot;socket creation error&quot;); return -1; } serv_addr.sin_family = AF_INET; serv_addr.sin_port = htons(PORT); if (inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;serv_addr.sin_addr) &lt;= 0) { perror(&quot;Invalid address&quot;); return -1; } if (connect(sock, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)) &lt; 0) { perror(&quot;Connection failed&quot;); return -1; } char request[BUFFER_SIZE]; snprintf(request, sizeof(request), &quot;%s %s&quot;, user, goods); send(sock, request, strlen(request), 0); read(sock, buffer, BUFFER_SIZE); printf(&quot;Order created with ID: %s\\n&quot;, buffer); close(sock); return 0;} 运行结果：","link":"/2025/09/17/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"},{"title":"牧神记","text":"《牧神记》推荐帖书籍简介《牧神记》是宅猪创作的一部东方奇幻小说，讲述了少年秦牧自弱小村落崛起，历经磨砺、智斗强敌，在广阔天地中追寻自我、守护家国的成长故事。小说世界观宏大，神话色彩浓厚，设定新颖，情节跌宕起伏。 推荐理由 世界观庞大作者构建了一个神、人、妖共存的天地，种族纷争、文明更迭，层层递进，非常有代入感。 主角成长线精彩秦牧从小村少年一步步成长为牧神，历经艰险，性格鲜明，奋斗历程令人热血沸腾。 设定创新神通、法术、机关、医学等元素融合，既有传统仙侠味道，也有奇幻新意。 文笔细腻，情感真挚宅猪的文字细腻，人物情感丰富，友情、师徒、家国情怀贯穿始终。 剧情紧凑，不拖沓情节推进快，高潮不断，伏笔众多，读起来让人欲罢不能。 适合人群 喜欢东方玄幻、仙侠小说的读者 喜欢主角成长、热血奋斗故事的朋友 对宏大世界观、神话设定有兴趣的读者 推荐语 “万象皆牧，天地为记。”《牧神记》不仅是一部奇幻仙侠，更是一场少年成长的冒险。强烈推荐给每一个喜欢热血、神话、成长故事的你！ 你有读过《牧神记》吗？欢迎留言交流你的感受和喜欢的角色/故事情节！","link":"/2025/09/17/%E7%89%A7%E7%A5%9E%E8%AE%B0/"},{"title":"Sherlock Holmes","text":"Sherlock Holmes介绍Sherlock Holmes 是由英国作家亚瑟·柯南·道尔创作的虚构侦探角色。他以极高的智力、出色的观察力和推理能力，解决了无数复杂的案件，成为侦探文学中的经典人物。Holmes 的形象已成为侦探类故事的代名词。 主要人物Sherlock Holmes 特点：敏锐的观察力，出色的推理能力，冷静的头脑。 技能：擅长从微小的细节中推测出案件真相，熟知化学、解剖学、犯罪心理学等学科。 Dr. John Watson 特点：Holmes 的忠实伙伴与朋友，通常是故事的叙述者。 技能：医生，军事背景，具有基本的侦探技巧和极高的忠诚度。 经典案件《巴斯克维尔的猎犬》这是 Sherlock Holmes 系列中的一个经典案件，讲述了一个关于家族诅咒和神秘猎犬的故事。Holmes 通过理性推理和对细节的关注揭开了真相。 《四签名》此案件涉及一系列神秘的死亡与失踪案件，Holmes 通过与Watson 的紧密合作，揭示了复杂的犯罪背后隐藏的秘密。 名言 “当你排除了不可能的，剩下的无论多么不可能，都是事实。” “我不相信没有合理解释的事情。” 结语Sherlock Holmes 的故事不仅仅是侦探小说，它们蕴含着深刻的逻辑推理和对人性的深刻洞察，成为了世界文学的经典之一。 这是一个简单的 Sherlock 主题页面，包含了基础的内容、人物介绍、经典案件和名言。你可以在这个基础上根据自己的需要扩展更多的内容。","link":"/2025/07/30/Sherlock%20Holmes/"},{"title":"阿西莫夫","text":"《基地系列》是美国科幻作家**艾萨克·阿西莫夫（Isaac Asimov）**的代表作之一，是科幻文学史上最重要的作品之一，深刻影响了科幻小说的发展。它由七部主要作品构成，讲述了未来银河帝国的崩溃和重建，以下是《基地系列》的简要介绍。 1. 背景设定《基地系列》的故事发生在未来的银河帝国时代。银河帝国是一个覆盖整个银河系的大型帝国，经过几千年的辉煌，最终面临衰退的命运。故事的核心思想是“心理史学”，由主角哈里·谢顿提出，这是一门通过数学模型预测历史趋势的科学。谢顿预言银河帝国将陷入衰退，预计将经历数万年的混乱期。然而，他设法创立了一个“基地”，通过保存科学和技术，尽可能缩短这个黑暗时代的时间。 2. 主要作品《基地系列》包括以下几部作品： 1. 《基地》（Foundation，1951）故事的起点，哈里·谢顿建立了“基地”计划，意图通过保存知识来加速帝国衰退后的复兴。故事涉及基地的建立与初期发展，讲述了不同的人物和势力如何影响这个计划。 2. 《基地与帝国》（Foundation and Empire，1952）在《基地》的基础上，银河帝国的余威依旧存在，而基地也在不断壮大。此书通过描述帝国与基地之间的冲突，展现了政治斗争和军备竞赛。 3. 《第二基地》（Second Foundation，1953）故事继续扩展基地系列的世界观，揭示了第二基地的存在和其在影响银河历史进程中的角色。第二基地的成员拥有强大的心灵能力，试图保持对基地计划的控制。 4. 《基地前奏》（Prelude to Foundation，1988）这部作品是《基地系列》的前传，讲述了哈里·谢顿如何提出心理史学理论并开始创建基地的故事。书中的焦点是谢顿如何应对来自各方势力的挑战。 5. 《基地与地球》（Foundation and Earth，1986）这是《基地系列》的后续作品，讲述了谢顿计划的遗产，以及基地如何寻找地球的遗址。它进一步探讨了人类未来的演变和银河系的命运。 6. 《回到基地》（Forward the Foundation，1993）这是《基地系列》的最后一部作品，讲述了哈里·谢顿的晚年和他最后的努力，以确保心理史学能够顺利进行，并且基础能够得以延续。 3. 核心思想《基地系列》通过对未来历史的描绘，探讨了人类社会、政治、科学、技术的关系。它的核心思想是**“大历史的进程”**，即人类社会的发展并非完全由个人的意志主导，而是受制于一系列宏大的历史和社会因素。 此外，心理史学这一概念也成为了该系列的标志，提出人类社会的集体行为可以通过数学模型进行预测和控制，虽然个体行为难以预测，但大规模的社会行为却有规律可循。这一理论启发了许多科幻作家的创作，甚至对一些现实中的社会学、经济学理论产生了影响。 4. 对科幻文学的影响《基地系列》对科幻文学的影响不可小觑，它不仅仅是一个科幻故事，更是对人类社会、历史、政治和科技的深刻反思。它奠定了未来“银河帝国”类型的科幻作品的基础，并且对于后来的科幻作品，如**《星际迷航》、《银河系漫游指南》**等，都产生了深远的影响。 5. 改编《基地系列》已经多次被改编成电影、电视剧等形式，最新的改编版本是由苹果公司制作的电视剧《基地》（2021年发布），该剧基于阿西莫夫的小说进行改编，虽然与原著有所不同，但依然保留了小说的核心理念和宏大的世界观。 总的来说，《基地系列》不仅仅是一部关于未来银河帝国的科幻作品，更是对人类命运和历史规律的深刻探讨，带有浓厚的哲学与社会学思考。如果你对社会、历史、心理学以及科技感兴趣，绝对不容错过。","link":"/2025/07/30/%E9%98%BF%E8%A5%BF%E8%8E%AB%E5%A4%AB/"}],"tags":[{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"动漫","slug":"动漫","link":"/tags/%E5%8A%A8%E6%BC%AB/"},{"name":"Sherlock","slug":"Sherlock","link":"/tags/Sherlock/"},{"name":"Detective","slug":"Detective","link":"/tags/Detective/"},{"name":"Mystery","slug":"Mystery","link":"/tags/Mystery/"},{"name":"science fiction","slug":"science-fiction","link":"/tags/science-fiction/"}],"categories":[],"pages":[]}