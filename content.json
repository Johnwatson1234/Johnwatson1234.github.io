{"posts":[{"title":"my first bolg","text":"ç°åŸå“€çš„åšå®¢ ğŸŒ¸â€œçœŸç›¸åªæœ‰ä¸€ä¸ªï¼Œè€Œæˆ‘ï¼Œåªæƒ³å®‰é™åœ°è§‚å¯Ÿä¸–ç•Œã€‚â€ ğŸ§¬ åšä¸»ç®€ä»‹ åå­—ï¼šç°åŸå“€ï¼ˆHaibara Aiï¼‰çœŸåï¼šå®«é‡å¿—ä¿ï¼ˆShiho Miyanoï¼‰åŸç»„ç»‡ä»£å·ï¼šé›ªè‰ï¼ˆSherryï¼‰èº«ä»½ï¼šå¤©æ‰å°‘å¥³ç§‘å­¦å®¶ã€APTX4869å¼€å‘è€…å½“å‰çŠ¶æ€ï¼šè¢«ç¼©å°ä¸ºå°å­¦ç”Ÿï¼Œå‡æ‰®å¸ä¸¹å°å­¦å­¦ç”Ÿ çƒ­çˆ±ç§‘ç ”ä¸å†·é™æ€è€ƒï¼Œæ›¾æ˜¯é»‘è¡£ç»„ç»‡æˆå‘˜ï¼Œåå› èƒŒå›ç»„ç»‡æœè¯å˜å°ã€‚æ€§æ ¼æ²‰é™ç†æ™ºï¼Œæ‹¥æœ‰éå‡¡çš„ç§‘å­¦å¤´è„‘ä¸æé«˜çš„æ´å¯ŸåŠ›ã€‚ ğŸ“š åšå®¢å†…å®¹æœ¬åšå®¢ä¸»è¦åˆ†äº«ä»¥ä¸‹å‡ ä¸ªæ–¹é¢çš„å†…å®¹ï¼š ğŸ”¬ ç§‘å­¦ä¸æ¨ç† åŒ–å­¦å®éªŒ &amp; APå¼€å‘ç¬”è®° çŠ¯ç½ªå¿ƒç†å­¦åˆ†æ æŸ¯å—æ¡ˆä»¶åˆ†æä¸å¤ç›˜ ğŸ’¡ æ€ç»´ä¸å“²å­¦ å¯¹äººæ€§çš„è§‚å¯Ÿä¸æ€è€ƒ å­˜åœ¨ä¸»ä¹‰ã€å®¿å‘½ä¸é€‰æ‹© ç»„ç»‡ä¸­çš„æƒåŠ›ç»“æ„æ¢æ ğŸ“ æ—¥å¸¸éšç¬” å¸ä¸¹å°å­¦ç”Ÿæ´»ç¢ç‰‡ ä¸å°‘å¹´ä¾¦æ¢å›¢çš„è¶£äº‹ ä¸å·¥è—¤æ–°ä¸€çš„è‹¥å¹²â€œæ— è¨€â€äº¤é”‹ ğŸ§Š åšä¸»æ ¼è¨€ â ä¸è¦å› ä¸ºå®³æ€•å¤±å»ï¼Œå°±ä¸å»çæƒœé‡è¦çš„ä¸œè¥¿ã€‚ââ€” ç°åŸå“€ ğŸ“® è”ç³»æ–¹å¼ ğŸ“§ Emailï¼šhaibara_ai@fbi.jp ğŸŒ GitHubï¼šgithub.com/HaibaraAi-Lab ğŸ“· Pixiv / æ’ç”»åˆé›†ï¼špixiv.net/users/haibara_ai ğŸ’¬ æœ€æ–°æ—¥å¿— 2025-07-14 â€”â€” æˆ‘æ¢¦è§å§å§åœ¨é›ªä¸­å¾®ç¬‘ï¼Œé†’æ¥åç»§ç»­ç ”ç©¶ AP çš„å‰¯ä½œç”¨ã€‚ 2025-06-30 â€”â€” å°‘å¹´ä¾¦æ¢å›¢åˆå‡ºåŠ¨äº†ï¼Œæˆ‘â€¦â€¦è¿˜æ˜¯é€‰æ‹©åœ¨ä¸€æ—è§‚å¯Ÿå§ã€‚ 2025-06-01 â€”â€” ã€Šæ¯’è¯ä¸è‡ªç”±æ„å¿—ã€‹è¿è½½å¼€å§‹ã€‚ ğŸ•µï¸â€â™€ï¸ ç‰¹åˆ«é¸£è°¢æ„Ÿè°¢é‚£ä½å˜´ç¡¬å¿ƒè½¯çš„åä¾¦æ¢ã€é‚£ç¾¤åµåµé—¹é—¹çš„ä¼™ä¼´ï¼Œä»¥åŠæ€»åœ¨æˆ‘æ¢¦ä¸­å‡ºç°çš„å§å§ã€‚ â€œæˆ‘ä¸ä¼šå›å¤´çš„ï¼Œå› ä¸ºæˆ‘çŸ¥é“ï¼Œå†å›å»å°±æ²¡æœ‰æœªæ¥äº†ã€‚â€â€” Haibara Ai","link":"/2025/07/14/%E7%81%B0%E5%8E%9F%E5%93%80/"},{"title":"è¿›ç¨‹é€šä¿¡æ–¹å¼","text":"è¿›ç¨‹é€šä¿¡æ–¹å¼åº”ç”¨ä¸ä»£ç ä¸€ã€å…±äº«å†…å­˜å…±äº«å­˜å‚¨å™¨ç³»ç»Ÿé€šè¿‡å…±äº«æ•°æ®ç»“æ„æˆ–å­˜å‚¨åŒºå®ç°é€šä¿¡ï¼Œé€‚ç”¨äºåŒä¸€ä¸»æœºå†…è¿›ç¨‹é—´çš„é«˜æ•ˆæ•°æ®äº¤æ¢ï¼Œå°¤å…¶é€‚åˆå¯¹é€šä¿¡æ•ˆç‡è¦æ±‚è¾ƒé«˜ã€éœ€é¢‘ç¹ä¼ è¾“å¤§é‡æ•°æ®çš„åœºæ™¯ã€‚ ï¼ˆä¸€ï¼‰åŸºäºå…±äº«æ•°æ®ç»“æ„çš„é€šä¿¡æ–¹å¼åº”ç”¨åœºæ™¯ï¼šä¸»è¦ç”¨äºè¿›ç¨‹é—´ä¼ é€’å°‘é‡æ§åˆ¶ä¿¡æ¯æˆ–ç®€å•æ•°æ®ï¼Œå…¸å‹æ¡ˆä¾‹ä¸º â€œç”Ÿäº§è€… - æ¶ˆè´¹è€…é—®é¢˜â€ã€‚åœ¨è¯¥é—®é¢˜ä¸­ï¼Œç”Ÿäº§è€…è¿›ç¨‹ä¸æ–­ç”Ÿæˆ â€œäº§å“â€ï¼ˆå¦‚æ•°æ®ï¼‰å¹¶æ”¾å…¥å…±äº«çš„æœ‰ç•Œç¼“å†²åŒºï¼ˆå…±äº«æ•°æ®ç»“æ„ï¼‰ï¼Œæ¶ˆè´¹è€…è¿›ç¨‹ä»ç¼“å†²åŒºä¸­å–å‡º â€œäº§å“â€ è¿›è¡Œå¤„ç†ï¼ŒäºŒè€…é€šè¿‡å¯¹ç¼“å†²åŒºçš„æ“ä½œå®ç°æ•°æ®äº¤æ¢ï¼Œä¸”éœ€ç”±ç¨‹åºå‘˜è‡ªè¡Œå®ç°äº’æ–¥ï¼ˆé¿å…åŒæ—¶æ“ä½œç¼“å†²åŒºï¼‰ä¸åŒæ­¥ï¼ˆç¼“å†²åŒºç©ºæ—¶æ¶ˆè´¹è€…ç­‰å¾…ã€ç¼“å†²åŒºæ»¡æ—¶ç”Ÿäº§è€…ç­‰å¾…ï¼‰é€»è¾‘ã€‚ä¾‹å¦‚ï¼Œåœ¨ä¸€ä¸ªç®€å•çš„æ–‡ä»¶å¤„ç†ç³»ç»Ÿä¸­ï¼Œç”Ÿäº§è€…è¿›ç¨‹è¯»å–æ–‡ä»¶æ•°æ®å¹¶å†™å…¥ç¼“å†²åŒºï¼Œæ¶ˆè´¹è€…è¿›ç¨‹ä»ç¼“å†²åŒºè¯»å–æ•°æ®è¿›è¡ŒåŠ å¯†å¤„ç†ï¼ŒäºŒè€…é€šè¿‡å…±äº«ç¼“å†²åŒºåè°ƒå·¥ä½œã€‚ consumer.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/sem.h&gt;#include &lt;unistd.h&gt;#define SHM_KEY 1234#define SEM_MUTEX_KEY 5678#define SEM_EMPTY_KEY 5679#define SEM_FULL_KEY 5680#define BUF_SIZE 5typedef struct { char buffer[BUF_SIZE][100]; int in; int out;} shm_struct;void sem_p(int semid) { struct sembuf sb = {0, -1, 0}; semop(semid, &amp;sb, 1);}void sem_v(int semid) { struct sembuf sb = {0, 1, 0}; semop(semid, &amp;sb, 1);}int main() { int shmid = shmget(SHM_KEY, sizeof(shm_struct), 0666); shm_struct *shm = (shm_struct *)shmat(shmid, NULL, 0); int sem_mutex = semget(SEM_MUTEX_KEY, 1, 0666); int sem_empty = semget(SEM_EMPTY_KEY, 1, 0666); int sem_full = semget(SEM_FULL_KEY, 1, 0666); while (1) { sem_p(sem_full); sem_p(sem_mutex); char data[100]; strcpy(data, shm-&gt;buffer[shm-&gt;out]); printf(&quot;Consumed: %s\\n&quot;, data); shm-&gt;out = (shm-&gt;out + 1) % BUF_SIZE; sem_v(sem_mutex); sem_v(sem_empty); if (strcmp(data, &quot;exit&quot;) == 0) break; } shmdt(shm); shmctl(shmid, IPC_RMID, NULL); return 0;} producer.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/sem.h&gt;#include &lt;unistd.h&gt;#define SHM_KEY 1234#define SEM_MUTEX_KEY 5678#define SEM_EMPTY_KEY 5679#define SEM_FULL_KEY 5680#define BUF_SIZE 5typedef struct { char buffer[BUF_SIZE][100]; int in; int out;} shm_struct;// ä¿¡å·é‡ P æ“ä½œvoid sem_p(int semid) { struct sembuf sb = {0, -1, 0}; semop(semid, &amp;sb, 1);}// ä¿¡å·é‡ V æ“ä½œvoid sem_v(int semid) { struct sembuf sb = {0, 1, 0}; semop(semid, &amp;sb, 1);}int main() { int shmid = shmget(SHM_KEY, sizeof(shm_struct), IPC_CREAT | 0666); shm_struct *shm = (shm_struct *)shmat(shmid, NULL, 0); int sem_mutex = semget(SEM_MUTEX_KEY, 1, IPC_CREAT | 0666); int sem_empty = semget(SEM_EMPTY_KEY, 1, IPC_CREAT | 0666); int sem_full = semget(SEM_FULL_KEY, 1, IPC_CREAT | 0666); // åˆå§‹åŒ–ä¿¡å·é‡ semctl(sem_mutex, 0, SETVAL, 1); semctl(sem_empty, 0, SETVAL, BUF_SIZE); semctl(sem_full, 0, SETVAL, 0); shm-&gt;in = shm-&gt;out = 0; char input[100]; while (1) { printf(&quot;Enter data (exit to quit): &quot;); scanf(&quot;%s&quot;, input); sem_p(sem_empty); sem_p(sem_mutex); strcpy(shm-&gt;buffer[shm-&gt;in], input); printf(&quot;Produced: %s\\n&quot;, input); shm-&gt;in = (shm-&gt;in + 1) % BUF_SIZE; sem_v(sem_mutex); sem_v(sem_full); if (strcmp(input, &quot;exit&quot;) == 0) break; } shmdt(shm); return 0;} è¿è¡Œç»“æœï¼š ï¼ˆäºŒï¼‰åŸºäºå…±äº«å­˜å‚¨åŒºçš„é€šä¿¡æ–¹å¼åº”ç”¨åœºæ™¯ï¼šé€‚ç”¨äºéœ€è¦åœ¨è¿›ç¨‹é—´é«˜æ•ˆä¼ è¾“å¤§é‡æ•°æ®çš„åœºæ™¯ï¼Œå¦‚å›¾åƒå¤„ç†ç³»ç»Ÿä¸­ï¼Œå›¾åƒé‡‡é›†è¿›ç¨‹å°†é‡‡é›†åˆ°çš„é«˜æ¸…å›¾åƒæ•°æ®å†™å…¥å…±äº«å­˜å‚¨åŒºï¼Œå›¾åƒåˆ†æè¿›ç¨‹ç›´æ¥ä»è¯¥å…±äº«å­˜å‚¨åŒºè¯»å–æ•°æ®è¿›è¡Œåˆ†æï¼Œæ— éœ€æ•°æ®åœ¨è¿›ç¨‹é—´å¤åˆ¶ï¼Œæå¤§æå‡äº†é€šä¿¡æ•ˆç‡ã€‚å†å¦‚ï¼Œè§†é¢‘ç¼–è¾‘è½¯ä»¶ä¸­ï¼Œè§†é¢‘è§£ç è¿›ç¨‹ä¸è§†é¢‘æ¸²æŸ“è¿›ç¨‹é€šè¿‡å…±äº«å­˜å‚¨åŒºäº¤æ¢è§£ç åçš„è§†é¢‘å¸§æ•°æ®ï¼Œç¡®ä¿è§†é¢‘æ’­æ”¾çš„æµç•…æ€§ã€‚ writer.cpp 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;unistd.h&gt;#define SHM_KEY 4321#define SIZE 1024int main() { int shmid = shmget(SHM_KEY, SIZE, IPC_CREAT | 0666); char *shm = (char *)shmat(shmid, NULL, 0); printf(&quot;Writer: Enter text: &quot;); fgets(shm, SIZE, stdin); printf(&quot;Writer: Data written to shared memory.\\n&quot;); shmdt(shm); return 0;} reader.cpp 1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;unistd.h&gt;#define SHM_KEY 4321#define SIZE 1024int main() { int shmid = shmget(SHM_KEY, SIZE, 0666); char *shm = (char *)shmat(shmid, NULL, 0); printf(&quot;Reader: Data read from shared memory: %s\\n&quot;, shm); shmdt(shm); shmctl(shmid, IPC_RMID, NULL); // åˆ é™¤å…±äº«å†…å­˜ return 0;} è¿è¡Œç»“æœï¼š äºŒã€ç®¡é“ï¼ˆåŒ¿å/å‘½åï¼‰ç®¡é“é€šä¿¡ç³»ç»Ÿé€šè¿‡å…±äº«æ–‡ä»¶ï¼ˆç®¡é“ï¼‰è¿æ¥è¯» / å†™è¿›ç¨‹ï¼Œé€‚ç”¨äºåŒä¸€ä¸»æœºå†…ä¸¤ä¸ªè¿›ç¨‹é—´çš„å•å‘æˆ–åŒå‘å­—èŠ‚æµä¼ è¾“ï¼Œé¦–åˆ›äº UNIX ç³»ç»Ÿï¼Œåè¢«å¤šç§æ“ä½œç³»ç»Ÿé‡‡ç”¨ã€‚ åº”ç”¨åœºæ™¯ åŒ¿åç®¡é“ï¼šä¸»è¦ç”¨äºçˆ¶è¿›ç¨‹ä¸å­è¿›ç¨‹é—´çš„é€šä¿¡ã€‚ä¾‹å¦‚ï¼Œåœ¨ä¸€ä¸ªå‘½ä»¤è¡Œå·¥å…·ä¸­ï¼Œçˆ¶è¿›ç¨‹åˆ›å»ºå­è¿›ç¨‹æ‰§è¡Œæ•°æ®é‡‡é›†ä»»åŠ¡ï¼Œå­è¿›ç¨‹å°†é‡‡é›†åˆ°çš„æ•°æ®é€šè¿‡æ— åç®¡é“å‘é€ç»™çˆ¶è¿›ç¨‹ï¼Œçˆ¶è¿›ç¨‹å¯¹æ•°æ®è¿›è¡Œæ±‡æ€»å±•ç¤ºã€‚ å‘½åç®¡é“ï¼šé€‚ç”¨äºåŒä¸€å°æœºå™¨ä¸Šä»»æ„ä¸¤ä¸ªè¿›ç¨‹é—´çš„é€šä¿¡ï¼Œå¦‚åœ¨ä¸€ä¸ªç›‘æ§ç³»ç»Ÿä¸­ï¼Œç›‘æ§è¿›ç¨‹ï¼ˆå†™è¿›ç¨‹ï¼‰å°†è®¾å¤‡çŠ¶æ€æ•°æ®å†™å…¥æœ‰åç®¡é“ï¼Œæ—¥å¿—è®°å½•è¿›ç¨‹ï¼ˆè¯»è¿›ç¨‹ï¼‰ä»æœ‰åç®¡é“è¯»å–æ•°æ®å¹¶å†™å…¥æ—¥å¿—æ–‡ä»¶ï¼Œå®ç°ç›‘æ§æ•°æ®çš„å®æ—¶è®°å½•ã€‚ ä»£ç ï¼š1. åŒ¿åç®¡é“ï¼ˆçˆ¶è¿›ç¨‹ä¸å­è¿›ç¨‹é€šä¿¡ï¼‰é€šè¿‡pipe()å‡½æ•°åˆ›å»ºæ— åç®¡é“ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/wait.h&gt;#define INPUT 0#define OUTPUT 1void main() { int file_descriptors[2]; // å­˜å‚¨ç®¡é“çš„ä¸¤ä¸ªæ–‡ä»¶æè¿°ç¬¦ pid_t pid; char buf[256]; int returned_count; // åˆ›å»ºæ— åç®¡é“ if (pipe(file_descriptors) == -1) { perror(&quot;pipe&quot;); exit(1); } // åˆ›å»ºå­è¿›ç¨‹ if ((pid = fork()) == -1) { perror(&quot;fork&quot;); exit(1); } if (pid == 0) { // å­è¿›ç¨‹ï¼šå†™æ•°æ®åˆ°ç®¡é“ printf(&quot;in the spawned (child) processâ€¦\\n&quot;); // å­è¿›ç¨‹åªéœ€å†™ï¼Œå…³é—­è¯»ç«¯ close(file_descriptors[INPUT]); // å‘ç®¡é“å†™å…¥æ•°æ® write(file_descriptors[OUTPUT], &quot;test data&quot;, strlen(&quot;test data&quot;)); exit(0); } else { // çˆ¶è¿›ç¨‹ï¼šä»ç®¡é“è¯»æ•°æ® printf(&quot;in the spawning (parent) processâ€¦\\n&quot;); // çˆ¶è¿›ç¨‹åªéœ€è¯»ï¼Œå…³é—­å†™ç«¯ close(file_descriptors[OUTPUT]); // ä»ç®¡é“è¯»å–æ•°æ® returned_count = read(file_descriptors[INPUT], buf, sizeof(buf)); printf(&quot;%d bytes of data received from spawned process: %s\\n&quot;, returned_count, buf); // ç­‰å¾…å­è¿›ç¨‹ç»“æŸ wait(NULL); }} è¿è¡Œç»“æœï¼š è¯¥ä»£ç ä¸­ï¼Œçˆ¶è¿›ç¨‹é€šè¿‡pipe()åˆ›å»ºæ— åç®¡é“ï¼Œå†é€šè¿‡fork()åˆ›å»ºå­è¿›ç¨‹ï¼›å­è¿›ç¨‹å…³é—­ç®¡é“è¯»ç«¯ï¼Œå‘ç®¡é“å†™å…¥ â€œtest dataâ€ï¼Œçˆ¶è¿›ç¨‹å…³é—­ç®¡é“å†™ç«¯ï¼Œä»ç®¡é“è¯»å–å­è¿›ç¨‹å‘é€çš„æ•°æ®å¹¶æ‰“å°ï¼Œå®ç°çˆ¶å­è¿›ç¨‹çš„ç®€å•é€šä¿¡ã€‚ 2. å‘½åç®¡é“ï¼ˆä»»æ„ä¸¤è¿›ç¨‹é€šä¿¡ï¼‰å‘½åç®¡é“å¯é€šè¿‡mkfifo()å‡½æ•°æˆ–mknodç³»ç»Ÿè°ƒç”¨åˆ›å»ºï¼Œä»¥ä¸‹æ˜¯å†™è¿›ç¨‹ä¸è¯»è¿›ç¨‹ä¸¤éƒ¨åˆ†ä»£ç ï¼š å†™è¿›ç¨‹ä»£ç ï¼ˆå‘æœ‰åç®¡é“å†™å…¥æ•°æ®ï¼‰ï¼š 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#define FIFO_NAME &quot;myfifo&quot;int main() { int fd; char buf[80]; // åˆ›å»ºæœ‰åç®¡é“ï¼Œæƒé™ä¸ºè¯»å†™ if (mkfifo(FIFO_NAME, 0666) == -1) { perror(&quot;mkfifo&quot;); exit(1); } // ä»¥å†™æ–¹å¼æ‰“å¼€æœ‰åç®¡é“ fd = open(FIFO_NAME, O_WRONLY); if (fd == -1) { perror(&quot;open&quot;); exit(1); } // å‘ç®¡é“å†™å…¥æ•°æ® sprintf(buf, &quot;this is test data for the named pipe example.\\n&quot;); write(fd, buf, strlen(buf)); printf(&quot;Write data to named pipe: %s&quot;, buf); // å…³é—­æ–‡ä»¶æè¿°ç¬¦ close(fd); // åˆ é™¤æœ‰åç®¡é“ï¼ˆå¯é€‰ï¼Œæ ¹æ®éœ€æ±‚å†³å®šæ˜¯å¦ä¿ç•™ï¼‰ unlink(FIFO_NAME);} è¿è¡Œç»“æœï¼š è¯»è¿›ç¨‹ä»£ç ï¼ˆä»æœ‰åç®¡é“è¯»å–æ•°æ®ï¼‰ï¼š 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#define FIFO_NAME &quot;myfifo&quot;int main() { int fd; char buf[80]; int count; // ä»¥è¯»æ–¹å¼æ‰“å¼€æœ‰åç®¡é“ï¼ˆè‹¥ç®¡é“æœªåˆ›å»ºï¼Œä¼šé˜»å¡ç­‰å¾…ï¼‰ fd = open(FIFO_NAME, O_RDONLY); if (fd == -1) { perror(&quot;open&quot;); exit(1); } // ä»ç®¡é“è¯»å–æ•°æ® count = read(fd, buf, sizeof(buf)); if (count &gt; 0) { printf(&quot;Received from named pipe: %s&quot;, buf); } // å…³é—­æ–‡ä»¶æè¿°ç¬¦ close(fd);} è¿è¡Œç»“æœï¼š ä¸Šè¿°ä»£ç ä¸­ï¼Œå†™è¿›ç¨‹é€šè¿‡mkfifo()åˆ›å»ºæœ‰åç®¡é“ â€œmyfifoâ€ï¼Œå¹¶å‘ç®¡é“å†™å…¥æµ‹è¯•æ•°æ®ï¼›è¯»è¿›ç¨‹æ‰“å¼€è¯¥æœ‰åç®¡é“ï¼Œè¯»å–æ•°æ®å¹¶æ‰“å°ï¼Œå®ç°åŒä¸€ä¸»æœºä¸Šä»»æ„ä¸¤è¿›ç¨‹çš„é€šä¿¡ã€‚ ä¸‰ã€æ¶ˆæ¯é˜Ÿåˆ—æ¶ˆæ¯ä¼ é€’ç³»ç»Ÿä»¥æ ¼å¼åŒ–æ¶ˆæ¯ä¸ºå•ä½ï¼Œé€šè¿‡ç³»ç»ŸåŸè¯­å®ç°è¿›ç¨‹é€šä¿¡ï¼Œéšè—åº•å±‚ç»†èŠ‚ï¼Œé€‚ç”¨äºå¤šå¤„ç†æœºç³»ç»Ÿã€åˆ†å¸ƒå¼ç³»ç»ŸåŠè®¡ç®—æœºç½‘ç»œç³»ç»Ÿï¼Œæ˜¯å½“å‰åº”ç”¨æœ€å¹¿æ³›çš„é€šä¿¡æœºåˆ¶ä¹‹ä¸€ã€‚ åº”ç”¨åœºæ™¯ ç›´æ¥é€šä¿¡æ–¹å¼ï¼šé€‚ç”¨äºè¿›ç¨‹é—´éœ€è¦ç›´æ¥äº¤äº’çš„åœºæ™¯ï¼Œå¦‚å³æ—¶é€šä¿¡è½¯ä»¶ä¸­ï¼Œç”¨æˆ· A çš„å®¢æˆ·ç«¯è¿›ç¨‹ï¼ˆå‘é€è¿›ç¨‹ï¼‰é€šè¿‡ç³»ç»Ÿæä¾›çš„å‘é€åŸè¯­ï¼Œç›´æ¥å°†æ¶ˆæ¯å‘é€ç»™ç”¨æˆ· B çš„å®¢æˆ·ç«¯è¿›ç¨‹ï¼ˆæ¥æ”¶è¿›ç¨‹ï¼‰ï¼Œå®ç°å®æ—¶èŠå¤©ã€‚åœ¨å¾®å†…æ ¸æ“ä½œç³»ç»Ÿä¸­ï¼Œå¾®å†…æ ¸ä¸å„ä¸ªæœåŠ¡å™¨è¿›ç¨‹ï¼ˆå¦‚æ–‡ä»¶æœåŠ¡å™¨ã€è¿›ç¨‹æœåŠ¡å™¨ï¼‰ä¹‹é—´çš„é€šä¿¡ä¹Ÿé‡‡ç”¨ç›´æ¥æ¶ˆæ¯ä¼ é€’æ–¹å¼ï¼Œå¾®å†…æ ¸é€šè¿‡å‘é€åŸè¯­å‘æŒ‡å®šæœåŠ¡å™¨è¿›ç¨‹å‘é€è¯·æ±‚æ¶ˆæ¯ï¼ŒæœåŠ¡å™¨è¿›ç¨‹å¤„ç†åé€šè¿‡æ¥æ”¶åŸè¯­è·å–æ¶ˆæ¯å¹¶å“åº”ã€‚ é—´æ¥é€šä¿¡æ–¹å¼ï¼ˆä¿¡ç®±é€šä¿¡ï¼‰ï¼šé€‚ç”¨äºè¿›ç¨‹é—´éå®æ—¶é€šä¿¡æˆ–ä¸€å¯¹å¤šã€å¤šå¯¹å¤šé€šä¿¡åœºæ™¯ï¼Œå¦‚ç”µå­é‚®ä»¶ç³»ç»Ÿä¸­ï¼Œå‘é€æ–¹çš„é‚®ä»¶å®¢æˆ·ç«¯è¿›ç¨‹ï¼ˆå‘é€è¿›ç¨‹ï¼‰å°†é‚®ä»¶æ¶ˆæ¯å‘é€åˆ°é‚®ä»¶æœåŠ¡å™¨çš„ â€œä¿¡ç®±â€ ä¸­ï¼Œæ¥æ”¶æ–¹çš„é‚®ä»¶å®¢æˆ·ç«¯è¿›ç¨‹ï¼ˆæ¥æ”¶è¿›ç¨‹ï¼‰åœ¨åˆé€‚çš„æ—¶é—´ä»è¯¥ â€œä¿¡ç®±â€ ä¸­è¯»å–é‚®ä»¶ï¼Œå®ç°éå®æ—¶é€šä¿¡ã€‚å†å¦‚ï¼Œå…¬å‘Šç³»ç»Ÿä¸­ï¼Œç³»ç»Ÿåˆ›å»ºä¸€ä¸ªå…¬ç”¨ä¿¡ç®±ï¼Œå¤šä¸ªå‘å¸ƒè¿›ç¨‹å‘ä¿¡ç®±ä¸­å‘é€å…¬å‘Šæ¶ˆæ¯ï¼Œå¤šä¸ªè®¢é˜…è¿›ç¨‹ä»ä¿¡ç®±ä¸­è¯»å–å…¬å‘Šï¼Œå®ç°å¤šå¯¹å¤šé€šä¿¡ã€‚ ä»£ç ä½†æ ¹æ®åŸç†å¯æ¢³ç†å‡ºåŸºäºåŸè¯­çš„é€šä¿¡é€»è¾‘ï¼ˆä¼ªä»£ç ï¼‰ï¼š 1. ç›´æ¥é€šä¿¡ï¼ˆå¯¹ç§°å¯»å€æ–¹å¼ï¼‰12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#define MSGKEY 1234 // æ¶ˆæ¯é˜Ÿåˆ—çš„ key// æ¶ˆæ¯ç»“æ„ä½“struct msgbuff { long mtype; // æ¶ˆæ¯ç±»å‹ï¼Œå¿…é¡» &gt;0 char mtext[100]; // æ¶ˆæ¯æ­£æ–‡};int main() { int msgid; struct msgbuff msg; // è·å–/åˆ›å»ºæ¶ˆæ¯é˜Ÿåˆ— msgid = msgget(MSGKEY, IPC_CREAT | 0666); if (msgid == -1) { perror(&quot;msgget&quot;); exit(1); } // å¡«å……æ¶ˆæ¯ msg.mtype = 1; // æŒ‡å®šæ¶ˆæ¯ç±»å‹ strcpy(msg.mtext, &quot;Hello, this is a message from P1.&quot;); // å‘é€æ¶ˆæ¯ if (msgsnd(msgid, &amp;msg, strlen(msg.mtext) + 1, 0) == -1) { perror(&quot;msgsnd&quot;); exit(1); } printf(&quot;Sender: Message sent: %s\\n&quot;, msg.mtext); return 0;} è¿è¡Œç»“æœï¼š 2. é—´æ¥é€šä¿¡ï¼ˆä¿¡ç®±é€šä¿¡ï¼‰123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#define MSGKEY 1234struct msgbuff { long mtype; char mtext[100];};int main() { int msgid; struct msgbuff msg; // æ‰“å¼€æ¶ˆæ¯é˜Ÿåˆ— msgid = msgget(MSGKEY, 0666); if (msgid == -1) { perror(&quot;msgget&quot;); exit(1); } // æ¥æ”¶ç±»å‹ä¸º 1 çš„æ¶ˆæ¯ if (msgrcv(msgid, &amp;msg, sizeof(msg.mtext), 1, 0) == -1) { perror(&quot;msgrcv&quot;); exit(1); } printf(&quot;Receiver: Received message: %s\\n&quot;, msg.mtext); // å¯é€‰ï¼šåˆ é™¤æ¶ˆæ¯é˜Ÿåˆ— msgctl(msgid, IPC_RMID, NULL); return 0;} è¿è¡Œç»“æœï¼š ä¸Šè¿°ä¼ªä»£ç ä½“ç°äº†æ¶ˆæ¯ä¼ é€’ç³»ç»Ÿçš„æ ¸å¿ƒé€»è¾‘ï¼šå‘é€è¿›ç¨‹é€šè¿‡send()åŸè¯­æŒ‡å®šæ¥æ”¶å¯¹è±¡ï¼ˆè¿›ç¨‹æˆ–ä¿¡ç®±ï¼‰å¹¶å‘é€æ¶ˆæ¯ï¼Œæ¥æ”¶è¿›ç¨‹é€šè¿‡receive()åŸè¯­è·å–æ¶ˆæ¯ï¼Œå®ç°é€šä¿¡ã€‚ å››ã€å¥—æ¥å­—ï¼ˆå®¢æˆ·æœº - æœåŠ¡å™¨ç³»ç»Ÿï¼‰å®¢æˆ·æœº - æœåŠ¡å™¨ç³»ç»Ÿæ˜¯ç½‘ç»œç¯å¢ƒä¸‹çš„ä¸»æµé€šä¿¡æœºåˆ¶ï¼Œé€šè¿‡å¥—æ¥å­—ã€è¿œç¨‹è¿‡ç¨‹è°ƒç”¨ï¼ˆRPCï¼‰ã€è¿œç¨‹æ–¹æ³•è°ƒç”¨å®ç°ï¼Œé€‚ç”¨äºè·¨ä¸»æœºçš„è¿›ç¨‹é€šä¿¡ï¼Œæ”¯æ’‘äº†ä¼—å¤šç½‘ç»œåº”ç”¨ã€‚ ï¼ˆä¸€ï¼‰å¥—æ¥å­—å¥—æ¥å­—æ˜¯è¿›ç¨‹é€šä¿¡ä¸ç½‘ç»œé€šä¿¡çš„åŸºæœ¬æ„ä»¶ï¼Œæ—¢é€‚åˆåŒä¸€ä¸»æœºå†…è¿›ç¨‹é€šä¿¡ï¼Œä¹Ÿé€‚ç”¨äºè·¨ä¸»æœºè¿›ç¨‹é€šä¿¡ï¼Œæ˜¯ WWW æœåŠ¡ã€FTP æœåŠ¡ã€Telnet æœåŠ¡ç­‰ç½‘ç»œåº”ç”¨çš„æ ¸å¿ƒé€šä¿¡æŠ€æœ¯ã€‚ åº”ç”¨åœºæ™¯ åŸºäºæ–‡ä»¶å‹å¥—æ¥å­—ï¼šé€‚åˆåŒä¸€ä¸»æœºå†…è¿›ç¨‹é—´çš„é€šä¿¡ï¼Œå¦‚æœ¬åœ°æ¡Œé¢åº”ç”¨ä¸­ï¼ŒéŸ³ä¹æ’­æ”¾å™¨è¿›ç¨‹ä¸æ­Œè¯æ˜¾ç¤ºè¿›ç¨‹é€šè¿‡åŸºäºæ–‡ä»¶çš„å¥—æ¥å­—é€šä¿¡ï¼ŒéŸ³ä¹æ’­æ”¾å™¨è¿›ç¨‹å°†å½“å‰æ’­æ”¾æ­Œæ›²çš„æ­Œè¯æ•°æ®å‘é€ç»™æ­Œè¯æ˜¾ç¤ºè¿›ç¨‹ï¼Œæ­Œè¯æ˜¾ç¤ºè¿›ç¨‹å®æ—¶æ›´æ–°æ­Œè¯ç•Œé¢ã€‚ åŸºäºç½‘ç»œå‹å¥—æ¥å­—ï¼šé€‚ç”¨äºè·¨ä¸»æœºçš„ç½‘ç»œé€šä¿¡ï¼Œå¦‚ Web æµè§ˆä¸­ï¼Œç”¨æˆ·çš„æµè§ˆå™¨è¿›ç¨‹ï¼ˆå®¢æˆ·ç«¯ï¼‰é€šè¿‡ç½‘ç»œå‹å¥—æ¥å­—è¿æ¥åˆ° Web æœåŠ¡å™¨è¿›ç¨‹ï¼ˆæœåŠ¡å™¨ç«¯ï¼‰ï¼Œå‘æœåŠ¡å™¨å‘é€ HTTP è¯·æ±‚æ¶ˆæ¯ï¼ŒæœåŠ¡å™¨å¤„ç†åå°†ç½‘é¡µæ•°æ®é€šè¿‡å¥—æ¥å­—è¿”å›ç»™æµè§ˆå™¨ï¼Œæµè§ˆå™¨æ¸²æŸ“ç½‘é¡µå¹¶å±•ç¤ºï¼›FTP æœåŠ¡ä¸­ï¼Œå®¢æˆ·ç«¯è¿›ç¨‹ä¸ FTP æœåŠ¡å™¨è¿›ç¨‹é€šè¿‡å¥—æ¥å­—å»ºç«‹è¿æ¥ï¼Œå®ç°æ–‡ä»¶çš„ä¸Šä¼ ä¸ä¸‹è½½ã€‚ åŸºäºç½‘ç»œå‹å¥—æ¥å­—çš„ç®€å• TCP é€šä¿¡ä»£ç ï¼š æœåŠ¡å™¨ç«¯ä»£ç ï¼ˆç›‘å¬å¹¶å¤„ç†å®¢æˆ·ç«¯è¯·æ±‚ï¼‰ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#define PORT 8080#define BUFFER_SIZE 1024int main() { int server_fd, new_socket; struct sockaddr_in address; int opt = 1; int addrlen = sizeof(address); char buffer[BUFFER_SIZE] = {0}; const char *hello = &quot;Hello from server&quot;; // åˆ›å»ºå¥—æ¥å­—æ–‡ä»¶æè¿°ç¬¦ if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) { perror(&quot;socket failed&quot;); exit(EXIT_FAILURE); } // è®¾ç½®å¥—æ¥å­—é€‰é¡¹ï¼Œå…è®¸é‡ç”¨ç«¯å£å’Œåœ°å€ if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &amp;opt, sizeof(opt))) { perror(&quot;setsockopt&quot;); exit(EXIT_FAILURE); } address.sin_family = AF_INET; address.sin_addr.s_addr = INADDR_ANY; // ç›‘å¬æ‰€æœ‰ç½‘ç»œæ¥å£ address.sin_port = htons(PORT); // å°†ä¸»æœºå­—èŠ‚åºè½¬ä¸ºç½‘ç»œå­—èŠ‚åº // ç»‘å®šå¥—æ¥å­—åˆ°æŒ‡å®šç«¯å£ if (bind(server_fd, (struct sockaddr *)&amp;address, sizeof(address)) &lt; 0) { perror(&quot;bind failed&quot;); exit(EXIT_FAILURE); } // ç›‘å¬å®¢æˆ·ç«¯è¿æ¥è¯·æ±‚ï¼Œæœ€å¤§ç­‰å¾…é˜Ÿåˆ—é•¿åº¦ä¸º3 if (listen(server_fd, 3) &lt; 0) { perror(&quot;listen&quot;); exit(EXIT_FAILURE); } // æ¥å—å®¢æˆ·ç«¯è¿æ¥ï¼Œåˆ›å»ºæ–°çš„å¥—æ¥å­—ç”¨äºé€šä¿¡ if ((new_socket = accept(server_fd, (struct sockaddr *)&amp;address, (socklen_t*)&amp;addrlen)) &lt; 0) { perror(&quot;accept&quot;); exit(EXIT_FAILURE); } // ä»å®¢æˆ·ç«¯è¯»å–æ•°æ® read(new_socket, buffer, BUFFER_SIZE); printf(&quot;Received from client: %s\\n&quot;, buffer); // å‘å®¢æˆ·ç«¯å‘é€æ•°æ® send(new_socket, hello, strlen(hello), 0); printf(&quot;Hello message sent to client\\n&quot;); // å…³é—­å¥—æ¥å­— close(new_socket); close(server_fd);} è¿è¡Œç»“æœï¼š å®¢æˆ·ç«¯ä»£ç ï¼ˆè¿æ¥æœåŠ¡å™¨å¹¶å‘é€è¯·æ±‚ï¼‰ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#define PORT 8080#define BUFFER_SIZE 1024void main() { int sock = 0; struct sockaddr_in serv_addr; char buffer[BUFFER_SIZE] = {0}; char *hello = &quot;Hello from client&quot;; // åˆ›å»ºå¥—æ¥å­—æ–‡ä»¶æè¿°ç¬¦ if ((sock = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) { printf(&quot;\\n Socket creation error \\n&quot;); exit(EXIT_FAILURE); } memset(&amp;serv_addr, '0', sizeof(serv_addr)); serv_addr.sin_family = AF_INET; serv_addr.sin_port = htons(PORT); // å°†IPv4åœ°å€ä»ç‚¹åˆ†åè¿›åˆ¶è½¬ä¸ºäºŒè¿›åˆ¶æ ¼å¼ if (inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;serv_addr.sin_addr) &lt;= 0) { printf(&quot;\\nInvalid address/ Address not supported \\n&quot;); exit(EXIT_FAILURE); } // è¿æ¥æœåŠ¡å™¨ if (connect(sock, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)) &lt; 0) { printf(&quot;\\nConnection Failed \\n&quot;); exit(EXIT_FAILURE); } // å‘æœåŠ¡å™¨å‘é€æ•°æ® send(sock, hello, strlen(hello), 0); printf(&quot;Hello message sent to server\\n&quot;); // ä»æœåŠ¡å™¨è¯»å–æ•°æ® read(sock, buffer, BUFFER_SIZE); printf(&quot;Received from server: %s\\n&quot;, buffer); // å…³é—­å¥—æ¥å­— close(sock);} è¿è¡Œç»“æœï¼š ä¸Šè¿°ä»£ç ä¸­ï¼ŒæœåŠ¡å™¨ç«¯é€šè¿‡socket()åˆ›å»ºå¥—æ¥å­—ï¼Œbind()ç»‘å®šç«¯å£ï¼Œlisten()ç›‘å¬è¿æ¥ï¼Œaccept()æ¥å—å®¢æˆ·ç«¯è¿æ¥åï¼Œä¸å®¢æˆ·ç«¯é€šè¿‡read()å’Œsend()äº¤æ¢æ•°æ®ï¼›å®¢æˆ·ç«¯é€šè¿‡socket()åˆ›å»ºå¥—æ¥å­—ï¼Œconnect()è¿æ¥æœåŠ¡å™¨ï¼Œå†é€šè¿‡send()å’Œread()ä¸æœåŠ¡å™¨é€šä¿¡ï¼Œä½“ç°äº†åŸºäºç½‘ç»œå‹å¥—æ¥å­—çš„è·¨è¿›ç¨‹ï¼ˆè·¨ä¸»æœºï¼‰é€šä¿¡è¿‡ç¨‹ã€‚ ï¼ˆäºŒï¼‰è¿œç¨‹è¿‡ç¨‹è°ƒç”¨ï¼ˆRPCï¼‰RPC å…è®¸æœ¬åœ°è¿›ç¨‹è°ƒç”¨è¿œç¨‹ä¸»æœºçš„è¿›ç¨‹ï¼Œå¯¹ç¨‹åºå‘˜è¡¨ç°ä¸ºå¸¸è§„è¿‡ç¨‹è°ƒç”¨ï¼Œé€‚ç”¨äºåˆ†å¸ƒå¼ç³»ç»Ÿä¸­è¿›ç¨‹é—´çš„è¿œç¨‹åŠŸèƒ½è°ƒç”¨ï¼Œå¦‚åˆ†å¸ƒå¼è®¡ç®—ã€è¿œç¨‹æœåŠ¡è°ƒç”¨ç­‰åœºæ™¯ã€‚ åº”ç”¨åœºæ™¯åœ¨åˆ†å¸ƒå¼æ–‡ä»¶ç³»ç»Ÿä¸­ï¼Œå®¢æˆ·ç«¯è¿›ç¨‹éœ€è¦è·å–è¿œç¨‹æ–‡ä»¶æœåŠ¡å™¨ä¸Šçš„æ–‡ä»¶ä¿¡æ¯ï¼ˆå¦‚æ–‡ä»¶å¤§å°ã€ä¿®æ”¹æ—¶é—´ï¼‰ï¼Œæ­¤æ—¶å®¢æˆ·ç«¯è¿›ç¨‹å¯é€šè¿‡ RPC è°ƒç”¨æ–‡ä»¶æœåŠ¡å™¨ä¸Šçš„ â€œè·å–æ–‡ä»¶ä¿¡æ¯â€ è¿‡ç¨‹ï¼šå®¢æˆ·ç«¯è¿›ç¨‹è°ƒç”¨æœ¬åœ°å…³è”çš„å®¢æˆ·å­˜æ ¹ï¼Œå­˜æ ¹å°†è°ƒç”¨å‚æ•°ï¼ˆå¦‚æ–‡ä»¶åï¼‰æ‰“åŒ…ä¸ºæ¶ˆæ¯å¹¶å‘é€ç»™æ–‡ä»¶æœåŠ¡å™¨ï¼›æœåŠ¡å™¨ç«¯çš„æœåŠ¡å™¨å­˜æ ¹æ¥æ”¶æ¶ˆæ¯ï¼Œè§£æå‚æ•°åè°ƒç”¨å®é™…çš„ â€œè·å–æ–‡ä»¶ä¿¡æ¯â€ è¿‡ç¨‹ï¼Œå°†ç»“æœè¿”å›ç»™æœåŠ¡å™¨å­˜æ ¹ï¼›æœåŠ¡å™¨å­˜æ ¹å°†ç»“æœæ‰“åŒ…ä¸ºæ¶ˆæ¯å‘é€å›å®¢æˆ·ç«¯ï¼Œå®¢æˆ·ç«¯å­˜æ ¹è§£ææ¶ˆæ¯å¹¶å°†ç»“æœè¿”å›ç»™å®¢æˆ·ç«¯è¿›ç¨‹ï¼Œæ•´ä¸ªè¿‡ç¨‹å¯¹å®¢æˆ·ç«¯ç¨‹åºå‘˜é€æ˜ï¼Œå¦‚åŒè°ƒç”¨æœ¬åœ°è¿‡ç¨‹ã€‚ åŸºäºå­˜æ ¹æœºåˆ¶çš„ RPC è°ƒç”¨ä»£ç ï¼šrpc_server.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/stat.h&gt;#define PORT 8081#define BUFFER_SIZE 1024// æ¨¡æ‹Ÿè¿œç¨‹è¿‡ç¨‹ï¼šè·å–æ–‡ä»¶å¤§å°long get_file_size(const char *filename) { struct stat st; if (stat(filename, &amp;st) == 0) return st.st_size; else return -1;}int main() { int server_fd, new_socket; struct sockaddr_in address; int addrlen = sizeof(address); char buffer[BUFFER_SIZE] = {0}; if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) { perror(&quot;socket failed&quot;); exit(EXIT_FAILURE); } address.sin_family = AF_INET; address.sin_addr.s_addr = INADDR_ANY; address.sin_port = htons(PORT); if (bind(server_fd, (struct sockaddr *)&amp;address, sizeof(address)) &lt; 0) { perror(&quot;bind failed&quot;); exit(EXIT_FAILURE); } if (listen(server_fd, 3) &lt; 0) { perror(&quot;listen&quot;); exit(EXIT_FAILURE); } printf(&quot;RPC Server running on port %d...\\n&quot;, PORT); while (1) { if ((new_socket = accept(server_fd, (struct sockaddr *)&amp;address, (socklen_t*)&amp;addrlen)) &lt; 0) { perror(&quot;accept&quot;); exit(EXIT_FAILURE); } memset(buffer, 0, BUFFER_SIZE); read(new_socket, buffer, BUFFER_SIZE); printf(&quot;Server received request: %s\\n&quot;, buffer); long size = get_file_size(buffer); char response[BUFFER_SIZE]; if (size &gt;= 0) snprintf(response, sizeof(response), &quot;File size: %ld bytes&quot;, size); else snprintf(response, sizeof(response), &quot;Error: cannot open file&quot;); send(new_socket, response, strlen(response), 0); close(new_socket); }} rpc_client.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#define PORT 8081#define BUFFER_SIZE 1024int main() { int sock = 0; struct sockaddr_in serv_addr; char buffer[BUFFER_SIZE] = {0}; char filename[BUFFER_SIZE]; printf(&quot;Enter filename: &quot;); scanf(&quot;%s&quot;, filename); if ((sock = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) { perror(&quot;socket creation error&quot;); return -1; } serv_addr.sin_family = AF_INET; serv_addr.sin_port = htons(PORT); if (inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;serv_addr.sin_addr) &lt;= 0) { perror(&quot;Invalid address&quot;); return -1; } if (connect(sock, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)) &lt; 0) { perror(&quot;Connection failed&quot;); return -1; } send(sock, filename, strlen(filename), 0); read(sock, buffer, BUFFER_SIZE); printf(&quot;Response from server: %s\\n&quot;, buffer); close(sock); return 0;} è¿è¡Œç»“æœï¼š ï¼ˆä¸‰ï¼‰è¿œç¨‹æ–¹æ³•è°ƒç”¨è¿œç¨‹æ–¹æ³•è°ƒç”¨æ˜¯é¢å‘å¯¹è±¡ç¼–ç¨‹ä¸‹çš„ RPCï¼Œé€‚ç”¨äºåˆ†å¸ƒå¼é¢å‘å¯¹è±¡ç³»ç»Ÿä¸­è¿œç¨‹å¯¹è±¡çš„æ–¹æ³•è°ƒç”¨ï¼Œå¦‚è¿œç¨‹å¯¹è±¡æœåŠ¡ã€åˆ†å¸ƒå¼é¢å‘å¯¹è±¡åº”ç”¨ç­‰åœºæ™¯ã€‚ åº”ç”¨åœºæ™¯ï¼šåœ¨åˆ†å¸ƒå¼ç”µå•†ç³»ç»Ÿä¸­ï¼Œå®¢æˆ·ç«¯åº”ç”¨ï¼ˆå¦‚æ‰‹æœºè´­ç‰© APP çš„åç«¯è¿›ç¨‹ï¼‰éœ€è¦è°ƒç”¨è¿œç¨‹è®¢å•æœåŠ¡å™¨ä¸Š â€œåˆ›å»ºè®¢å•â€ çš„å¯¹è±¡æ–¹æ³•ï¼šå®¢æˆ·ç«¯è¿›ç¨‹æŒæœ‰è¿œç¨‹è®¢å•å¯¹è±¡çš„å¼•ç”¨ï¼Œè°ƒç”¨è¯¥å¯¹è±¡çš„create_order(user_id, goods_list)æ–¹æ³•ï¼›å®¢æˆ·ç«¯å­˜æ ¹å°†æ–¹æ³•åï¼ˆcreate_orderï¼‰ã€å‚æ•°ï¼ˆç”¨æˆ· IDã€å•†å“åˆ—è¡¨ï¼‰æ‰“åŒ…ä¸ºæ¶ˆæ¯å¹¶å‘é€ç»™è®¢å•æœåŠ¡å™¨ï¼›æœåŠ¡å™¨ç«¯çš„æœåŠ¡å™¨å­˜æ ¹æ¥æ”¶æ¶ˆæ¯ï¼Œè§£æåè°ƒç”¨è®¢å•å¯¹è±¡çš„å®é™…create_orderæ–¹æ³•ï¼Œç”Ÿæˆè®¢å•å¹¶è¿”å›è®¢å•å·ï¼›æœåŠ¡å™¨å­˜æ ¹å°†è®¢å•å·æ‰“åŒ…ä¸ºæ¶ˆæ¯å‘é€å›å®¢æˆ·ç«¯ï¼Œå®¢æˆ·ç«¯å­˜æ ¹è§£ææ¶ˆæ¯å¹¶å°†è®¢å•å·è¿”å›ç»™å®¢æˆ·ç«¯è¿›ç¨‹ï¼Œæ•´ä¸ªè¿‡ç¨‹ç¬¦åˆé¢å‘å¯¹è±¡ç¼–ç¨‹èŒƒå¼ï¼Œå¯¹å®¢æˆ·ç«¯ç¨‹åºå‘˜é€æ˜ã€‚ é¢å‘å¯¹è±¡åœºæ™¯ä¸‹çš„è¿œç¨‹æ–¹æ³•è°ƒç”¨ä»£ç ï¼šrmi_server.cppï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;time.h&gt;#define PORT 8082#define BUFFER_SIZE 1024// æ¨¡æ‹Ÿè¿œç¨‹å¯¹è±¡æ–¹æ³•ï¼šåˆ›å»ºè®¢å•void create_order(const char *user, const char *goods, char *order_id) { srand(time(NULL)); int num = rand() % 10000; snprintf(order_id, BUFFER_SIZE, &quot;ORDER-%s-%s-%d&quot;, user, goods, num);}int main() { int server_fd, new_socket; struct sockaddr_in address; int addrlen = sizeof(address); char buffer[BUFFER_SIZE] = {0}; if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) { perror(&quot;socket failed&quot;); exit(EXIT_FAILURE); } address.sin_family = AF_INET; address.sin_addr.s_addr = INADDR_ANY; address.sin_port = htons(PORT); if (bind(server_fd, (struct sockaddr *)&amp;address, sizeof(address)) &lt; 0) { perror(&quot;bind failed&quot;); exit(EXIT_FAILURE); } if (listen(server_fd, 3) &lt; 0) { perror(&quot;listen&quot;); exit(EXIT_FAILURE); } printf(&quot;RMI Server running on port %d...\\n&quot;, PORT); while (1) { if ((new_socket = accept(server_fd, (struct sockaddr *)&amp;address, (socklen_t*)&amp;addrlen)) &lt; 0) { perror(&quot;accept&quot;); exit(EXIT_FAILURE); } memset(buffer, 0, BUFFER_SIZE); read(new_socket, buffer, BUFFER_SIZE); printf(&quot;Server received request: %s\\n&quot;, buffer); // è§£æè¾“å…¥ï¼šuser goods char user[50], goods[50]; sscanf(buffer, &quot;%s %s&quot;, user, goods); char order_id[BUFFER_SIZE]; create_order(user, goods, order_id); send(new_socket, order_id, strlen(order_id), 0); close(new_socket); }} rmi_client.cppï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#define PORT 8082#define BUFFER_SIZE 1024int main() { int sock = 0; struct sockaddr_in serv_addr; char buffer[BUFFER_SIZE] = {0}; char user[50], goods[50]; printf(&quot;Enter user ID: &quot;); scanf(&quot;%s&quot;, user); printf(&quot;Enter goods: &quot;); scanf(&quot;%s&quot;, goods); if ((sock = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) { perror(&quot;socket creation error&quot;); return -1; } serv_addr.sin_family = AF_INET; serv_addr.sin_port = htons(PORT); if (inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;serv_addr.sin_addr) &lt;= 0) { perror(&quot;Invalid address&quot;); return -1; } if (connect(sock, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)) &lt; 0) { perror(&quot;Connection failed&quot;); return -1; } char request[BUFFER_SIZE]; snprintf(request, sizeof(request), &quot;%s %s&quot;, user, goods); send(sock, request, strlen(request), 0); read(sock, buffer, BUFFER_SIZE); printf(&quot;Order created with ID: %s\\n&quot;, buffer); close(sock); return 0;} è¿è¡Œç»“æœï¼š","link":"/2025/09/17/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"},{"title":"ç‰§ç¥è®°","text":"ã€Šç‰§ç¥è®°ã€‹æ¨èå¸–ä¹¦ç±ç®€ä»‹ã€Šç‰§ç¥è®°ã€‹æ˜¯å®…çŒªåˆ›ä½œçš„ä¸€éƒ¨ä¸œæ–¹å¥‡å¹»å°è¯´ï¼Œè®²è¿°äº†å°‘å¹´ç§¦ç‰§è‡ªå¼±å°æ‘è½å´›èµ·ï¼Œå†ç»ç£¨ç ºã€æ™ºæ–—å¼ºæ•Œï¼Œåœ¨å¹¿é˜”å¤©åœ°ä¸­è¿½å¯»è‡ªæˆ‘ã€å®ˆæŠ¤å®¶å›½çš„æˆé•¿æ•…äº‹ã€‚å°è¯´ä¸–ç•Œè§‚å®å¤§ï¼Œç¥è¯è‰²å½©æµ“åšï¼Œè®¾å®šæ–°é¢–ï¼Œæƒ…èŠ‚è·Œå®•èµ·ä¼ã€‚ æ¨èç†ç”± ä¸–ç•Œè§‚åºå¤§ä½œè€…æ„å»ºäº†ä¸€ä¸ªç¥ã€äººã€å¦–å…±å­˜çš„å¤©åœ°ï¼Œç§æ—çº·äº‰ã€æ–‡æ˜æ›´è¿­ï¼Œå±‚å±‚é€’è¿›ï¼Œéå¸¸æœ‰ä»£å…¥æ„Ÿã€‚ ä¸»è§’æˆé•¿çº¿ç²¾å½©ç§¦ç‰§ä»å°æ‘å°‘å¹´ä¸€æ­¥æ­¥æˆé•¿ä¸ºç‰§ç¥ï¼Œå†ç»è‰°é™©ï¼Œæ€§æ ¼é²œæ˜ï¼Œå¥‹æ–—å†ç¨‹ä»¤äººçƒ­è¡€æ²¸è…¾ã€‚ è®¾å®šåˆ›æ–°ç¥é€šã€æ³•æœ¯ã€æœºå…³ã€åŒ»å­¦ç­‰å…ƒç´ èåˆï¼Œæ—¢æœ‰ä¼ ç»Ÿä»™ä¾ å‘³é“ï¼Œä¹Ÿæœ‰å¥‡å¹»æ–°æ„ã€‚ æ–‡ç¬”ç»†è…»ï¼Œæƒ…æ„ŸçœŸæŒšå®…çŒªçš„æ–‡å­—ç»†è…»ï¼Œäººç‰©æƒ…æ„Ÿä¸°å¯Œï¼Œå‹æƒ…ã€å¸ˆå¾’ã€å®¶å›½æƒ…æ€€è´¯ç©¿å§‹ç»ˆã€‚ å‰§æƒ…ç´§å‡‘ï¼Œä¸æ‹–æ²“æƒ…èŠ‚æ¨è¿›å¿«ï¼Œé«˜æ½®ä¸æ–­ï¼Œä¼ç¬”ä¼—å¤šï¼Œè¯»èµ·æ¥è®©äººæ¬²ç½¢ä¸èƒ½ã€‚ é€‚åˆäººç¾¤ å–œæ¬¢ä¸œæ–¹ç„å¹»ã€ä»™ä¾ å°è¯´çš„è¯»è€… å–œæ¬¢ä¸»è§’æˆé•¿ã€çƒ­è¡€å¥‹æ–—æ•…äº‹çš„æœ‹å‹ å¯¹å®å¤§ä¸–ç•Œè§‚ã€ç¥è¯è®¾å®šæœ‰å…´è¶£çš„è¯»è€… æ¨èè¯­ â€œä¸‡è±¡çš†ç‰§ï¼Œå¤©åœ°ä¸ºè®°ã€‚â€ã€Šç‰§ç¥è®°ã€‹ä¸ä»…æ˜¯ä¸€éƒ¨å¥‡å¹»ä»™ä¾ ï¼Œæ›´æ˜¯ä¸€åœºå°‘å¹´æˆé•¿çš„å†’é™©ã€‚å¼ºçƒˆæ¨èç»™æ¯ä¸€ä¸ªå–œæ¬¢çƒ­è¡€ã€ç¥è¯ã€æˆé•¿æ•…äº‹çš„ä½ ï¼ ä½ æœ‰è¯»è¿‡ã€Šç‰§ç¥è®°ã€‹å—ï¼Ÿæ¬¢è¿ç•™è¨€äº¤æµä½ çš„æ„Ÿå—å’Œå–œæ¬¢çš„è§’è‰²/æ•…äº‹æƒ…èŠ‚ï¼","link":"/2025/09/17/%E7%89%A7%E7%A5%9E%E8%AE%B0/"},{"title":"Sherlock Holmes","text":"Sherlock Holmesä»‹ç»Sherlock Holmes æ˜¯ç”±è‹±å›½ä½œå®¶äºšç‘ŸÂ·æŸ¯å—Â·é“å°”åˆ›ä½œçš„è™šæ„ä¾¦æ¢è§’è‰²ã€‚ä»–ä»¥æé«˜çš„æ™ºåŠ›ã€å‡ºè‰²çš„è§‚å¯ŸåŠ›å’Œæ¨ç†èƒ½åŠ›ï¼Œè§£å†³äº†æ— æ•°å¤æ‚çš„æ¡ˆä»¶ï¼Œæˆä¸ºä¾¦æ¢æ–‡å­¦ä¸­çš„ç»å…¸äººç‰©ã€‚Holmes çš„å½¢è±¡å·²æˆä¸ºä¾¦æ¢ç±»æ•…äº‹çš„ä»£åè¯ã€‚ ä¸»è¦äººç‰©Sherlock Holmes ç‰¹ç‚¹ï¼šæ•é”çš„è§‚å¯ŸåŠ›ï¼Œå‡ºè‰²çš„æ¨ç†èƒ½åŠ›ï¼Œå†·é™çš„å¤´è„‘ã€‚ æŠ€èƒ½ï¼šæ“…é•¿ä»å¾®å°çš„ç»†èŠ‚ä¸­æ¨æµ‹å‡ºæ¡ˆä»¶çœŸç›¸ï¼Œç†ŸçŸ¥åŒ–å­¦ã€è§£å‰–å­¦ã€çŠ¯ç½ªå¿ƒç†å­¦ç­‰å­¦ç§‘ã€‚ Dr. John Watson ç‰¹ç‚¹ï¼šHolmes çš„å¿ å®ä¼™ä¼´ä¸æœ‹å‹ï¼Œé€šå¸¸æ˜¯æ•…äº‹çš„å™è¿°è€…ã€‚ æŠ€èƒ½ï¼šåŒ»ç”Ÿï¼Œå†›äº‹èƒŒæ™¯ï¼Œå…·æœ‰åŸºæœ¬çš„ä¾¦æ¢æŠ€å·§å’Œæé«˜çš„å¿ è¯šåº¦ã€‚ ç»å…¸æ¡ˆä»¶ã€Šå·´æ–¯å…‹ç»´å°”çš„çŒçŠ¬ã€‹è¿™æ˜¯ Sherlock Holmes ç³»åˆ—ä¸­çš„ä¸€ä¸ªç»å…¸æ¡ˆä»¶ï¼Œè®²è¿°äº†ä¸€ä¸ªå…³äºå®¶æ—è¯…å’’å’Œç¥ç§˜çŒçŠ¬çš„æ•…äº‹ã€‚Holmes é€šè¿‡ç†æ€§æ¨ç†å’Œå¯¹ç»†èŠ‚çš„å…³æ³¨æ­å¼€äº†çœŸç›¸ã€‚ ã€Šå››ç­¾åã€‹æ­¤æ¡ˆä»¶æ¶‰åŠä¸€ç³»åˆ—ç¥ç§˜çš„æ­»äº¡ä¸å¤±è¸ªæ¡ˆä»¶ï¼ŒHolmes é€šè¿‡ä¸Watson çš„ç´§å¯†åˆä½œï¼Œæ­ç¤ºäº†å¤æ‚çš„çŠ¯ç½ªèƒŒåéšè—çš„ç§˜å¯†ã€‚ åè¨€ â€œå½“ä½ æ’é™¤äº†ä¸å¯èƒ½çš„ï¼Œå‰©ä¸‹çš„æ— è®ºå¤šä¹ˆä¸å¯èƒ½ï¼Œéƒ½æ˜¯äº‹å®ã€‚â€ â€œæˆ‘ä¸ç›¸ä¿¡æ²¡æœ‰åˆç†è§£é‡Šçš„äº‹æƒ…ã€‚â€ ç»“è¯­Sherlock Holmes çš„æ•…äº‹ä¸ä»…ä»…æ˜¯ä¾¦æ¢å°è¯´ï¼Œå®ƒä»¬è•´å«ç€æ·±åˆ»çš„é€»è¾‘æ¨ç†å’Œå¯¹äººæ€§çš„æ·±åˆ»æ´å¯Ÿï¼Œæˆä¸ºäº†ä¸–ç•Œæ–‡å­¦çš„ç»å…¸ä¹‹ä¸€ã€‚ è¿™æ˜¯ä¸€ä¸ªç®€å•çš„ Sherlock ä¸»é¢˜é¡µé¢ï¼ŒåŒ…å«äº†åŸºç¡€çš„å†…å®¹ã€äººç‰©ä»‹ç»ã€ç»å…¸æ¡ˆä»¶å’Œåè¨€ã€‚ä½ å¯ä»¥åœ¨è¿™ä¸ªåŸºç¡€ä¸Šæ ¹æ®è‡ªå·±çš„éœ€è¦æ‰©å±•æ›´å¤šçš„å†…å®¹ã€‚","link":"/2025/07/30/Sherlock%20Holmes/"},{"title":"é˜¿è¥¿è«å¤«","text":"ã€ŠåŸºåœ°ç³»åˆ—ã€‹æ˜¯ç¾å›½ç§‘å¹»ä½œå®¶**è‰¾è¨å…‹Â·é˜¿è¥¿è«å¤«ï¼ˆIsaac Asimovï¼‰**çš„ä»£è¡¨ä½œä¹‹ä¸€ï¼Œæ˜¯ç§‘å¹»æ–‡å­¦å²ä¸Šæœ€é‡è¦çš„ä½œå“ä¹‹ä¸€ï¼Œæ·±åˆ»å½±å“äº†ç§‘å¹»å°è¯´çš„å‘å±•ã€‚å®ƒç”±ä¸ƒéƒ¨ä¸»è¦ä½œå“æ„æˆï¼Œè®²è¿°äº†æœªæ¥é“¶æ²³å¸å›½çš„å´©æºƒå’Œé‡å»ºï¼Œä»¥ä¸‹æ˜¯ã€ŠåŸºåœ°ç³»åˆ—ã€‹çš„ç®€è¦ä»‹ç»ã€‚ 1. èƒŒæ™¯è®¾å®šã€ŠåŸºåœ°ç³»åˆ—ã€‹çš„æ•…äº‹å‘ç”Ÿåœ¨æœªæ¥çš„é“¶æ²³å¸å›½æ—¶ä»£ã€‚é“¶æ²³å¸å›½æ˜¯ä¸€ä¸ªè¦†ç›–æ•´ä¸ªé“¶æ²³ç³»çš„å¤§å‹å¸å›½ï¼Œç»è¿‡å‡ åƒå¹´çš„è¾‰ç…Œï¼Œæœ€ç»ˆé¢ä¸´è¡°é€€çš„å‘½è¿ã€‚æ•…äº‹çš„æ ¸å¿ƒæ€æƒ³æ˜¯â€œå¿ƒç†å²å­¦â€ï¼Œç”±ä¸»è§’å“ˆé‡ŒÂ·è°¢é¡¿æå‡ºï¼Œè¿™æ˜¯ä¸€é—¨é€šè¿‡æ•°å­¦æ¨¡å‹é¢„æµ‹å†å²è¶‹åŠ¿çš„ç§‘å­¦ã€‚è°¢é¡¿é¢„è¨€é“¶æ²³å¸å›½å°†é™·å…¥è¡°é€€ï¼Œé¢„è®¡å°†ç»å†æ•°ä¸‡å¹´çš„æ··ä¹±æœŸã€‚ç„¶è€Œï¼Œä»–è®¾æ³•åˆ›ç«‹äº†ä¸€ä¸ªâ€œåŸºåœ°â€ï¼Œé€šè¿‡ä¿å­˜ç§‘å­¦å’ŒæŠ€æœ¯ï¼Œå°½å¯èƒ½ç¼©çŸ­è¿™ä¸ªé»‘æš—æ—¶ä»£çš„æ—¶é—´ã€‚ 2. ä¸»è¦ä½œå“ã€ŠåŸºåœ°ç³»åˆ—ã€‹åŒ…æ‹¬ä»¥ä¸‹å‡ éƒ¨ä½œå“ï¼š 1. ã€ŠåŸºåœ°ã€‹ï¼ˆFoundationï¼Œ1951ï¼‰æ•…äº‹çš„èµ·ç‚¹ï¼Œå“ˆé‡ŒÂ·è°¢é¡¿å»ºç«‹äº†â€œåŸºåœ°â€è®¡åˆ’ï¼Œæ„å›¾é€šè¿‡ä¿å­˜çŸ¥è¯†æ¥åŠ é€Ÿå¸å›½è¡°é€€åçš„å¤å…´ã€‚æ•…äº‹æ¶‰åŠåŸºåœ°çš„å»ºç«‹ä¸åˆæœŸå‘å±•ï¼Œè®²è¿°äº†ä¸åŒçš„äººç‰©å’ŒåŠ¿åŠ›å¦‚ä½•å½±å“è¿™ä¸ªè®¡åˆ’ã€‚ 2. ã€ŠåŸºåœ°ä¸å¸å›½ã€‹ï¼ˆFoundation and Empireï¼Œ1952ï¼‰åœ¨ã€ŠåŸºåœ°ã€‹çš„åŸºç¡€ä¸Šï¼Œé“¶æ²³å¸å›½çš„ä½™å¨ä¾æ—§å­˜åœ¨ï¼Œè€ŒåŸºåœ°ä¹Ÿåœ¨ä¸æ–­å£®å¤§ã€‚æ­¤ä¹¦é€šè¿‡æè¿°å¸å›½ä¸åŸºåœ°ä¹‹é—´çš„å†²çªï¼Œå±•ç°äº†æ”¿æ²»æ–—äº‰å’Œå†›å¤‡ç«èµ›ã€‚ 3. ã€Šç¬¬äºŒåŸºåœ°ã€‹ï¼ˆSecond Foundationï¼Œ1953ï¼‰æ•…äº‹ç»§ç»­æ‰©å±•åŸºåœ°ç³»åˆ—çš„ä¸–ç•Œè§‚ï¼Œæ­ç¤ºäº†ç¬¬äºŒåŸºåœ°çš„å­˜åœ¨å’Œå…¶åœ¨å½±å“é“¶æ²³å†å²è¿›ç¨‹ä¸­çš„è§’è‰²ã€‚ç¬¬äºŒåŸºåœ°çš„æˆå‘˜æ‹¥æœ‰å¼ºå¤§çš„å¿ƒçµèƒ½åŠ›ï¼Œè¯•å›¾ä¿æŒå¯¹åŸºåœ°è®¡åˆ’çš„æ§åˆ¶ã€‚ 4. ã€ŠåŸºåœ°å‰å¥ã€‹ï¼ˆPrelude to Foundationï¼Œ1988ï¼‰è¿™éƒ¨ä½œå“æ˜¯ã€ŠåŸºåœ°ç³»åˆ—ã€‹çš„å‰ä¼ ï¼Œè®²è¿°äº†å“ˆé‡ŒÂ·è°¢é¡¿å¦‚ä½•æå‡ºå¿ƒç†å²å­¦ç†è®ºå¹¶å¼€å§‹åˆ›å»ºåŸºåœ°çš„æ•…äº‹ã€‚ä¹¦ä¸­çš„ç„¦ç‚¹æ˜¯è°¢é¡¿å¦‚ä½•åº”å¯¹æ¥è‡ªå„æ–¹åŠ¿åŠ›çš„æŒ‘æˆ˜ã€‚ 5. ã€ŠåŸºåœ°ä¸åœ°çƒã€‹ï¼ˆFoundation and Earthï¼Œ1986ï¼‰è¿™æ˜¯ã€ŠåŸºåœ°ç³»åˆ—ã€‹çš„åç»­ä½œå“ï¼Œè®²è¿°äº†è°¢é¡¿è®¡åˆ’çš„é—äº§ï¼Œä»¥åŠåŸºåœ°å¦‚ä½•å¯»æ‰¾åœ°çƒçš„é—å€ã€‚å®ƒè¿›ä¸€æ­¥æ¢è®¨äº†äººç±»æœªæ¥çš„æ¼”å˜å’Œé“¶æ²³ç³»çš„å‘½è¿ã€‚ 6. ã€Šå›åˆ°åŸºåœ°ã€‹ï¼ˆForward the Foundationï¼Œ1993ï¼‰è¿™æ˜¯ã€ŠåŸºåœ°ç³»åˆ—ã€‹çš„æœ€åä¸€éƒ¨ä½œå“ï¼Œè®²è¿°äº†å“ˆé‡ŒÂ·è°¢é¡¿çš„æ™šå¹´å’Œä»–æœ€åçš„åŠªåŠ›ï¼Œä»¥ç¡®ä¿å¿ƒç†å²å­¦èƒ½å¤Ÿé¡ºåˆ©è¿›è¡Œï¼Œå¹¶ä¸”åŸºç¡€èƒ½å¤Ÿå¾—ä»¥å»¶ç»­ã€‚ 3. æ ¸å¿ƒæ€æƒ³ã€ŠåŸºåœ°ç³»åˆ—ã€‹é€šè¿‡å¯¹æœªæ¥å†å²çš„æç»˜ï¼Œæ¢è®¨äº†äººç±»ç¤¾ä¼šã€æ”¿æ²»ã€ç§‘å­¦ã€æŠ€æœ¯çš„å…³ç³»ã€‚å®ƒçš„æ ¸å¿ƒæ€æƒ³æ˜¯**â€œå¤§å†å²çš„è¿›ç¨‹â€**ï¼Œå³äººç±»ç¤¾ä¼šçš„å‘å±•å¹¶éå®Œå…¨ç”±ä¸ªäººçš„æ„å¿—ä¸»å¯¼ï¼Œè€Œæ˜¯å—åˆ¶äºä¸€ç³»åˆ—å®å¤§çš„å†å²å’Œç¤¾ä¼šå› ç´ ã€‚ æ­¤å¤–ï¼Œå¿ƒç†å²å­¦è¿™ä¸€æ¦‚å¿µä¹Ÿæˆä¸ºäº†è¯¥ç³»åˆ—çš„æ ‡å¿—ï¼Œæå‡ºäººç±»ç¤¾ä¼šçš„é›†ä½“è¡Œä¸ºå¯ä»¥é€šè¿‡æ•°å­¦æ¨¡å‹è¿›è¡Œé¢„æµ‹å’Œæ§åˆ¶ï¼Œè™½ç„¶ä¸ªä½“è¡Œä¸ºéš¾ä»¥é¢„æµ‹ï¼Œä½†å¤§è§„æ¨¡çš„ç¤¾ä¼šè¡Œä¸ºå´æœ‰è§„å¾‹å¯å¾ªã€‚è¿™ä¸€ç†è®ºå¯å‘äº†è®¸å¤šç§‘å¹»ä½œå®¶çš„åˆ›ä½œï¼Œç”šè‡³å¯¹ä¸€äº›ç°å®ä¸­çš„ç¤¾ä¼šå­¦ã€ç»æµå­¦ç†è®ºäº§ç”Ÿäº†å½±å“ã€‚ 4. å¯¹ç§‘å¹»æ–‡å­¦çš„å½±å“ã€ŠåŸºåœ°ç³»åˆ—ã€‹å¯¹ç§‘å¹»æ–‡å­¦çš„å½±å“ä¸å¯å°è§‘ï¼Œå®ƒä¸ä»…ä»…æ˜¯ä¸€ä¸ªç§‘å¹»æ•…äº‹ï¼Œæ›´æ˜¯å¯¹äººç±»ç¤¾ä¼šã€å†å²ã€æ”¿æ²»å’Œç§‘æŠ€çš„æ·±åˆ»åæ€ã€‚å®ƒå¥ å®šäº†æœªæ¥â€œé“¶æ²³å¸å›½â€ç±»å‹çš„ç§‘å¹»ä½œå“çš„åŸºç¡€ï¼Œå¹¶ä¸”å¯¹äºåæ¥çš„ç§‘å¹»ä½œå“ï¼Œå¦‚**ã€Šæ˜Ÿé™…è¿·èˆªã€‹ã€ã€Šé“¶æ²³ç³»æ¼«æ¸¸æŒ‡å—ã€‹**ç­‰ï¼Œéƒ½äº§ç”Ÿäº†æ·±è¿œçš„å½±å“ã€‚ 5. æ”¹ç¼–ã€ŠåŸºåœ°ç³»åˆ—ã€‹å·²ç»å¤šæ¬¡è¢«æ”¹ç¼–æˆç”µå½±ã€ç”µè§†å‰§ç­‰å½¢å¼ï¼Œæœ€æ–°çš„æ”¹ç¼–ç‰ˆæœ¬æ˜¯ç”±è‹¹æœå…¬å¸åˆ¶ä½œçš„ç”µè§†å‰§ã€ŠåŸºåœ°ã€‹ï¼ˆ2021å¹´å‘å¸ƒï¼‰ï¼Œè¯¥å‰§åŸºäºé˜¿è¥¿è«å¤«çš„å°è¯´è¿›è¡Œæ”¹ç¼–ï¼Œè™½ç„¶ä¸åŸè‘—æœ‰æ‰€ä¸åŒï¼Œä½†ä¾ç„¶ä¿ç•™äº†å°è¯´çš„æ ¸å¿ƒç†å¿µå’Œå®å¤§çš„ä¸–ç•Œè§‚ã€‚ æ€»çš„æ¥è¯´ï¼Œã€ŠåŸºåœ°ç³»åˆ—ã€‹ä¸ä»…ä»…æ˜¯ä¸€éƒ¨å…³äºæœªæ¥é“¶æ²³å¸å›½çš„ç§‘å¹»ä½œå“ï¼Œæ›´æ˜¯å¯¹äººç±»å‘½è¿å’Œå†å²è§„å¾‹çš„æ·±åˆ»æ¢è®¨ï¼Œå¸¦æœ‰æµ“åšçš„å“²å­¦ä¸ç¤¾ä¼šå­¦æ€è€ƒã€‚å¦‚æœä½ å¯¹ç¤¾ä¼šã€å†å²ã€å¿ƒç†å­¦ä»¥åŠç§‘æŠ€æ„Ÿå…´è¶£ï¼Œç»å¯¹ä¸å®¹é”™è¿‡ã€‚","link":"/2025/07/30/%E9%98%BF%E8%A5%BF%E8%8E%AB%E5%A4%AB/"}],"tags":[{"name":"æ“ä½œç³»ç»Ÿ","slug":"æ“ä½œç³»ç»Ÿ","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"åŠ¨æ¼«","slug":"åŠ¨æ¼«","link":"/tags/%E5%8A%A8%E6%BC%AB/"},{"name":"Sherlock","slug":"Sherlock","link":"/tags/Sherlock/"},{"name":"Detective","slug":"Detective","link":"/tags/Detective/"},{"name":"Mystery","slug":"Mystery","link":"/tags/Mystery/"},{"name":"science fiction","slug":"science-fiction","link":"/tags/science-fiction/"}],"categories":[],"pages":[]}