{"posts":[{"title":"manim初次尝试","text":"环境配置与安装安装 FFmpeg, 并且保证它在 PATH 环境变量中当你在控制台中输入 ffmpeg -version ，能打印出 FFmpeg 的版本号，那么就安装成功了安装一个 LaTeX 发行版，推荐 TeXLive-full 12345git clone https://github.com/3b1b/manim.gitcd manimconda create -n manim python=3.8conda activate manimpip install -e . 简单按键运行这个命令： 1manimgl start.py SquareToCircle 屏幕上会弹出一个窗口，这时你可以：滚动鼠标中键来上下移动画面按住键盘上 z 键的同时滚动鼠标中键来缩放画面按住键盘上 f 键的同时移动鼠标来平移画面按住键盘上 d 键的同时移动鼠标来改变三维视角按下键盘上 r 键恢复到最初的视角 命令行123manimgl &lt;code&gt;.py &lt;Scene&gt; &lt;flags&gt;# 或manim-render &lt;code&gt;.py &lt;Scene&gt; &lt;flags&gt; python manim实现冒泡排序可视化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from manimlib import *class BubbleSortScene(Scene): def construct(self): array = [5, 3, 8, 4, 2] title = Text(&quot;冒泡排序 Bubble Sort&quot;, font_size=36).to_edge(UP) self.add(title) rects, nums = self.create_array(array) self.add(rects, nums) self.wait(1) n = len(array) for i in range(n): for j in range(n - 1 - i): # 高亮比较的两个元素 self.play( rects[j].animate.set_fill(RED, opacity=0.5), rects[j+1].animate.set_fill(BLUE, opacity=0.5), run_time=0.3 ) if array[j] &gt; array[j+1]: # 交换数值 array[j], array[j+1] = array[j+1], array[j] self.play( nums[j].animate.move_to(rects[j+1]), nums[j+1].animate.move_to(rects[j]), run_time=0.5 ) # 用 submobjects 交换引用，避免 TypeError nums.submobjects[j], nums.submobjects[j+1] = nums.submobjects[j+1], nums.submobjects[j] # 恢复颜色 self.play( rects[j].animate.set_fill(WHITE, opacity=0), rects[j+1].animate.set_fill(WHITE, opacity=0), run_time=0.2 ) self.wait(2) def create_array(self, arr): rects = VGroup() nums = VGroup() for idx, val in enumerate(arr): rect = Square(side_length=1).shift(RIGHT * idx) num = Text(str(val), font_size=32).move_to(rect) rects.add(rect) nums.add(num) rects.move_to(ORIGIN) nums.move_to(ORIGIN) return rects, nums","link":"/2025/10/01/manim%E5%88%9D%E6%AC%A1%E5%B0%9D%E8%AF%95/"},{"title":"进程通信方式","text":"进程通信方式应用与代码一、共享内存共享存储器系统通过共享数据结构或存储区实现通信，适用于同一主机内进程间的高效数据交换，尤其适合对通信效率要求较高、需频繁传输大量数据的场景。 （一）基于共享数据结构的通信方式应用场景：主要用于进程间传递少量控制信息或简单数据，典型案例为 “生产者 - 消费者问题”。在该问题中，生产者进程不断生成 “产品”（如数据）并放入共享的有界缓冲区（共享数据结构），消费者进程从缓冲区中取出 “产品” 进行处理，二者通过对缓冲区的操作实现数据交换，且需由程序员自行实现互斥（避免同时操作缓冲区）与同步（缓冲区空时消费者等待、缓冲区满时生产者等待）逻辑。例如，在一个简单的文件处理系统中，生产者进程读取文件数据并写入缓冲区，消费者进程从缓冲区读取数据进行加密处理，二者通过共享缓冲区协调工作。 consumer.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/sem.h&gt;#include &lt;unistd.h&gt;#define SHM_KEY 1234#define SEM_MUTEX_KEY 5678#define SEM_EMPTY_KEY 5679#define SEM_FULL_KEY 5680#define BUF_SIZE 5typedef struct { char buffer[BUF_SIZE][100]; int in; int out;} shm_struct;void sem_p(int semid) { struct sembuf sb = {0, -1, 0}; semop(semid, &amp;sb, 1);}void sem_v(int semid) { struct sembuf sb = {0, 1, 0}; semop(semid, &amp;sb, 1);}int main() { int shmid = shmget(SHM_KEY, sizeof(shm_struct), 0666); shm_struct *shm = (shm_struct *)shmat(shmid, NULL, 0); int sem_mutex = semget(SEM_MUTEX_KEY, 1, 0666); int sem_empty = semget(SEM_EMPTY_KEY, 1, 0666); int sem_full = semget(SEM_FULL_KEY, 1, 0666); while (1) { sem_p(sem_full); sem_p(sem_mutex); char data[100]; strcpy(data, shm-&gt;buffer[shm-&gt;out]); printf(&quot;Consumed: %s\\n&quot;, data); shm-&gt;out = (shm-&gt;out + 1) % BUF_SIZE; sem_v(sem_mutex); sem_v(sem_empty); if (strcmp(data, &quot;exit&quot;) == 0) break; } shmdt(shm); shmctl(shmid, IPC_RMID, NULL); return 0;} producer.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/sem.h&gt;#include &lt;unistd.h&gt;#define SHM_KEY 1234#define SEM_MUTEX_KEY 5678#define SEM_EMPTY_KEY 5679#define SEM_FULL_KEY 5680#define BUF_SIZE 5typedef struct { char buffer[BUF_SIZE][100]; int in; int out;} shm_struct;// 信号量 P 操作void sem_p(int semid) { struct sembuf sb = {0, -1, 0}; semop(semid, &amp;sb, 1);}// 信号量 V 操作void sem_v(int semid) { struct sembuf sb = {0, 1, 0}; semop(semid, &amp;sb, 1);}int main() { int shmid = shmget(SHM_KEY, sizeof(shm_struct), IPC_CREAT | 0666); shm_struct *shm = (shm_struct *)shmat(shmid, NULL, 0); int sem_mutex = semget(SEM_MUTEX_KEY, 1, IPC_CREAT | 0666); int sem_empty = semget(SEM_EMPTY_KEY, 1, IPC_CREAT | 0666); int sem_full = semget(SEM_FULL_KEY, 1, IPC_CREAT | 0666); // 初始化信号量 semctl(sem_mutex, 0, SETVAL, 1); semctl(sem_empty, 0, SETVAL, BUF_SIZE); semctl(sem_full, 0, SETVAL, 0); shm-&gt;in = shm-&gt;out = 0; char input[100]; while (1) { printf(&quot;Enter data (exit to quit): &quot;); scanf(&quot;%s&quot;, input); sem_p(sem_empty); sem_p(sem_mutex); strcpy(shm-&gt;buffer[shm-&gt;in], input); printf(&quot;Produced: %s\\n&quot;, input); shm-&gt;in = (shm-&gt;in + 1) % BUF_SIZE; sem_v(sem_mutex); sem_v(sem_full); if (strcmp(input, &quot;exit&quot;) == 0) break; } shmdt(shm); return 0;} 运行结果： （二）基于共享存储区的通信方式应用场景：适用于需要在进程间高效传输大量数据的场景，如图像处理系统中，图像采集进程将采集到的高清图像数据写入共享存储区，图像分析进程直接从该共享存储区读取数据进行分析，无需数据在进程间复制，极大提升了通信效率。再如，视频编辑软件中，视频解码进程与视频渲染进程通过共享存储区交换解码后的视频帧数据，确保视频播放的流畅性。 writer.cpp 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;unistd.h&gt;#define SHM_KEY 4321#define SIZE 1024int main() { int shmid = shmget(SHM_KEY, SIZE, IPC_CREAT | 0666); char *shm = (char *)shmat(shmid, NULL, 0); printf(&quot;Writer: Enter text: &quot;); fgets(shm, SIZE, stdin); printf(&quot;Writer: Data written to shared memory.\\n&quot;); shmdt(shm); return 0;} reader.cpp 1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;unistd.h&gt;#define SHM_KEY 4321#define SIZE 1024int main() { int shmid = shmget(SHM_KEY, SIZE, 0666); char *shm = (char *)shmat(shmid, NULL, 0); printf(&quot;Reader: Data read from shared memory: %s\\n&quot;, shm); shmdt(shm); shmctl(shmid, IPC_RMID, NULL); // 删除共享内存 return 0;} 运行结果： 二、管道（匿名/命名）管道通信系统通过共享文件（管道）连接读 / 写进程，适用于同一主机内两个进程间的单向或双向字节流传输，首创于 UNIX 系统，后被多种操作系统采用。 应用场景 匿名管道：主要用于父进程与子进程间的通信。例如，在一个命令行工具中，父进程创建子进程执行数据采集任务，子进程将采集到的数据通过无名管道发送给父进程，父进程对数据进行汇总展示。 命名管道：适用于同一台机器上任意两个进程间的通信，如在一个监控系统中，监控进程（写进程）将设备状态数据写入有名管道，日志记录进程（读进程）从有名管道读取数据并写入日志文件，实现监控数据的实时记录。 代码：1. 匿名管道（父进程与子进程通信）通过pipe()函数创建无名管道： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/wait.h&gt;#define INPUT 0#define OUTPUT 1void main() { int file_descriptors[2]; // 存储管道的两个文件描述符 pid_t pid; char buf[256]; int returned_count; // 创建无名管道 if (pipe(file_descriptors) == -1) { perror(&quot;pipe&quot;); exit(1); } // 创建子进程 if ((pid = fork()) == -1) { perror(&quot;fork&quot;); exit(1); } if (pid == 0) { // 子进程：写数据到管道 printf(&quot;in the spawned (child) process…\\n&quot;); // 子进程只需写，关闭读端 close(file_descriptors[INPUT]); // 向管道写入数据 write(file_descriptors[OUTPUT], &quot;test data&quot;, strlen(&quot;test data&quot;)); exit(0); } else { // 父进程：从管道读数据 printf(&quot;in the spawning (parent) process…\\n&quot;); // 父进程只需读，关闭写端 close(file_descriptors[OUTPUT]); // 从管道读取数据 returned_count = read(file_descriptors[INPUT], buf, sizeof(buf)); printf(&quot;%d bytes of data received from spawned process: %s\\n&quot;, returned_count, buf); // 等待子进程结束 wait(NULL); }} 运行结果： 该代码中，父进程通过pipe()创建无名管道，再通过fork()创建子进程；子进程关闭管道读端，向管道写入 “test data”，父进程关闭管道写端，从管道读取子进程发送的数据并打印，实现父子进程的简单通信。 2. 命名管道（任意两进程通信）命名管道可通过mkfifo()函数或mknod系统调用创建，以下是写进程与读进程两部分代码： 写进程代码（向有名管道写入数据）： 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#define FIFO_NAME &quot;myfifo&quot;int main() { int fd; char buf[80]; // 创建有名管道，权限为读写 if (mkfifo(FIFO_NAME, 0666) == -1) { perror(&quot;mkfifo&quot;); exit(1); } // 以写方式打开有名管道 fd = open(FIFO_NAME, O_WRONLY); if (fd == -1) { perror(&quot;open&quot;); exit(1); } // 向管道写入数据 sprintf(buf, &quot;this is test data for the named pipe example.\\n&quot;); write(fd, buf, strlen(buf)); printf(&quot;Write data to named pipe: %s&quot;, buf); // 关闭文件描述符 close(fd); // 删除有名管道（可选，根据需求决定是否保留） unlink(FIFO_NAME);} 运行结果： 读进程代码（从有名管道读取数据）： 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#define FIFO_NAME &quot;myfifo&quot;int main() { int fd; char buf[80]; int count; // 以读方式打开有名管道（若管道未创建，会阻塞等待） fd = open(FIFO_NAME, O_RDONLY); if (fd == -1) { perror(&quot;open&quot;); exit(1); } // 从管道读取数据 count = read(fd, buf, sizeof(buf)); if (count &gt; 0) { printf(&quot;Received from named pipe: %s&quot;, buf); } // 关闭文件描述符 close(fd);} 运行结果： 上述代码中，写进程通过mkfifo()创建有名管道 “myfifo”，并向管道写入测试数据；读进程打开该有名管道，读取数据并打印，实现同一主机上任意两进程的通信。 三、消息队列消息传递系统以格式化消息为单位，通过系统原语实现进程通信，隐藏底层细节，适用于多处理机系统、分布式系统及计算机网络系统，是当前应用最广泛的通信机制之一。 应用场景 直接通信方式：适用于进程间需要直接交互的场景，如即时通信软件中，用户 A 的客户端进程（发送进程）通过系统提供的发送原语，直接将消息发送给用户 B 的客户端进程（接收进程），实现实时聊天。在微内核操作系统中，微内核与各个服务器进程（如文件服务器、进程服务器）之间的通信也采用直接消息传递方式，微内核通过发送原语向指定服务器进程发送请求消息，服务器进程处理后通过接收原语获取消息并响应。 间接通信方式（信箱通信）：适用于进程间非实时通信或一对多、多对多通信场景，如电子邮件系统中，发送方的邮件客户端进程（发送进程）将邮件消息发送到邮件服务器的 “信箱” 中，接收方的邮件客户端进程（接收进程）在合适的时间从该 “信箱” 中读取邮件，实现非实时通信。再如，公告系统中，系统创建一个公用信箱，多个发布进程向信箱中发送公告消息，多个订阅进程从信箱中读取公告，实现多对多通信。 代码但根据原理可梳理出基于原语的通信逻辑（伪代码）： 1. 直接通信（对称寻址方式）12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#define MSGKEY 1234 // 消息队列的 key// 消息结构体struct msgbuff { long mtype; // 消息类型，必须 &gt;0 char mtext[100]; // 消息正文};int main() { int msgid; struct msgbuff msg; // 获取/创建消息队列 msgid = msgget(MSGKEY, IPC_CREAT | 0666); if (msgid == -1) { perror(&quot;msgget&quot;); exit(1); } // 填充消息 msg.mtype = 1; // 指定消息类型 strcpy(msg.mtext, &quot;Hello, this is a message from P1.&quot;); // 发送消息 if (msgsnd(msgid, &amp;msg, strlen(msg.mtext) + 1, 0) == -1) { perror(&quot;msgsnd&quot;); exit(1); } printf(&quot;Sender: Message sent: %s\\n&quot;, msg.mtext); return 0;} 运行结果： 2. 间接通信（信箱通信）123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#define MSGKEY 1234struct msgbuff { long mtype; char mtext[100];};int main() { int msgid; struct msgbuff msg; // 打开消息队列 msgid = msgget(MSGKEY, 0666); if (msgid == -1) { perror(&quot;msgget&quot;); exit(1); } // 接收类型为 1 的消息 if (msgrcv(msgid, &amp;msg, sizeof(msg.mtext), 1, 0) == -1) { perror(&quot;msgrcv&quot;); exit(1); } printf(&quot;Receiver: Received message: %s\\n&quot;, msg.mtext); // 可选：删除消息队列 msgctl(msgid, IPC_RMID, NULL); return 0;} 运行结果： 上述伪代码体现了消息传递系统的核心逻辑：发送进程通过send()原语指定接收对象（进程或信箱）并发送消息，接收进程通过receive()原语获取消息，实现通信。 四、套接字（客户机 - 服务器系统）客户机 - 服务器系统是网络环境下的主流通信机制，通过套接字、远程过程调用（RPC）、远程方法调用实现，适用于跨主机的进程通信，支撑了众多网络应用。 （一）套接字套接字是进程通信与网络通信的基本构件，既适合同一主机内进程通信，也适用于跨主机进程通信，是 WWW 服务、FTP 服务、Telnet 服务等网络应用的核心通信技术。 应用场景 基于文件型套接字：适合同一主机内进程间的通信，如本地桌面应用中，音乐播放器进程与歌词显示进程通过基于文件的套接字通信，音乐播放器进程将当前播放歌曲的歌词数据发送给歌词显示进程，歌词显示进程实时更新歌词界面。 基于网络型套接字：适用于跨主机的网络通信，如 Web 浏览中，用户的浏览器进程（客户端）通过网络型套接字连接到 Web 服务器进程（服务器端），向服务器发送 HTTP 请求消息，服务器处理后将网页数据通过套接字返回给浏览器，浏览器渲染网页并展示；FTP 服务中，客户端进程与 FTP 服务器进程通过套接字建立连接，实现文件的上传与下载。 基于网络型套接字的简单 TCP 通信代码： 服务器端代码（监听并处理客户端请求）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#define PORT 8080#define BUFFER_SIZE 1024int main() { int server_fd, new_socket; struct sockaddr_in address; int opt = 1; int addrlen = sizeof(address); char buffer[BUFFER_SIZE] = {0}; const char *hello = &quot;Hello from server&quot;; // 创建套接字文件描述符 if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) { perror(&quot;socket failed&quot;); exit(EXIT_FAILURE); } // 设置套接字选项，允许重用端口和地址 if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &amp;opt, sizeof(opt))) { perror(&quot;setsockopt&quot;); exit(EXIT_FAILURE); } address.sin_family = AF_INET; address.sin_addr.s_addr = INADDR_ANY; // 监听所有网络接口 address.sin_port = htons(PORT); // 将主机字节序转为网络字节序 // 绑定套接字到指定端口 if (bind(server_fd, (struct sockaddr *)&amp;address, sizeof(address)) &lt; 0) { perror(&quot;bind failed&quot;); exit(EXIT_FAILURE); } // 监听客户端连接请求，最大等待队列长度为3 if (listen(server_fd, 3) &lt; 0) { perror(&quot;listen&quot;); exit(EXIT_FAILURE); } // 接受客户端连接，创建新的套接字用于通信 if ((new_socket = accept(server_fd, (struct sockaddr *)&amp;address, (socklen_t*)&amp;addrlen)) &lt; 0) { perror(&quot;accept&quot;); exit(EXIT_FAILURE); } // 从客户端读取数据 read(new_socket, buffer, BUFFER_SIZE); printf(&quot;Received from client: %s\\n&quot;, buffer); // 向客户端发送数据 send(new_socket, hello, strlen(hello), 0); printf(&quot;Hello message sent to client\\n&quot;); // 关闭套接字 close(new_socket); close(server_fd);} 运行结果： 客户端代码（连接服务器并发送请求）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#define PORT 8080#define BUFFER_SIZE 1024void main() { int sock = 0; struct sockaddr_in serv_addr; char buffer[BUFFER_SIZE] = {0}; char *hello = &quot;Hello from client&quot;; // 创建套接字文件描述符 if ((sock = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) { printf(&quot;\\n Socket creation error \\n&quot;); exit(EXIT_FAILURE); } memset(&amp;serv_addr, '0', sizeof(serv_addr)); serv_addr.sin_family = AF_INET; serv_addr.sin_port = htons(PORT); // 将IPv4地址从点分十进制转为二进制格式 if (inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;serv_addr.sin_addr) &lt;= 0) { printf(&quot;\\nInvalid address/ Address not supported \\n&quot;); exit(EXIT_FAILURE); } // 连接服务器 if (connect(sock, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)) &lt; 0) { printf(&quot;\\nConnection Failed \\n&quot;); exit(EXIT_FAILURE); } // 向服务器发送数据 send(sock, hello, strlen(hello), 0); printf(&quot;Hello message sent to server\\n&quot;); // 从服务器读取数据 read(sock, buffer, BUFFER_SIZE); printf(&quot;Received from server: %s\\n&quot;, buffer); // 关闭套接字 close(sock);} 运行结果： 上述代码中，服务器端通过socket()创建套接字，bind()绑定端口，listen()监听连接，accept()接受客户端连接后，与客户端通过read()和send()交换数据；客户端通过socket()创建套接字，connect()连接服务器，再通过send()和read()与服务器通信，体现了基于网络型套接字的跨进程（跨主机）通信过程。 （二）远程过程调用（RPC）RPC 允许本地进程调用远程主机的进程，对程序员表现为常规过程调用，适用于分布式系统中进程间的远程功能调用，如分布式计算、远程服务调用等场景。 应用场景在分布式文件系统中，客户端进程需要获取远程文件服务器上的文件信息（如文件大小、修改时间），此时客户端进程可通过 RPC 调用文件服务器上的 “获取文件信息” 过程：客户端进程调用本地关联的客户存根，存根将调用参数（如文件名）打包为消息并发送给文件服务器；服务器端的服务器存根接收消息，解析参数后调用实际的 “获取文件信息” 过程，将结果返回给服务器存根；服务器存根将结果打包为消息发送回客户端，客户端存根解析消息并将结果返回给客户端进程，整个过程对客户端程序员透明，如同调用本地过程。 基于存根机制的 RPC 调用代码：rpc_server.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/stat.h&gt;#define PORT 8081#define BUFFER_SIZE 1024// 模拟远程过程：获取文件大小long get_file_size(const char *filename) { struct stat st; if (stat(filename, &amp;st) == 0) return st.st_size; else return -1;}int main() { int server_fd, new_socket; struct sockaddr_in address; int addrlen = sizeof(address); char buffer[BUFFER_SIZE] = {0}; if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) { perror(&quot;socket failed&quot;); exit(EXIT_FAILURE); } address.sin_family = AF_INET; address.sin_addr.s_addr = INADDR_ANY; address.sin_port = htons(PORT); if (bind(server_fd, (struct sockaddr *)&amp;address, sizeof(address)) &lt; 0) { perror(&quot;bind failed&quot;); exit(EXIT_FAILURE); } if (listen(server_fd, 3) &lt; 0) { perror(&quot;listen&quot;); exit(EXIT_FAILURE); } printf(&quot;RPC Server running on port %d...\\n&quot;, PORT); while (1) { if ((new_socket = accept(server_fd, (struct sockaddr *)&amp;address, (socklen_t*)&amp;addrlen)) &lt; 0) { perror(&quot;accept&quot;); exit(EXIT_FAILURE); } memset(buffer, 0, BUFFER_SIZE); read(new_socket, buffer, BUFFER_SIZE); printf(&quot;Server received request: %s\\n&quot;, buffer); long size = get_file_size(buffer); char response[BUFFER_SIZE]; if (size &gt;= 0) snprintf(response, sizeof(response), &quot;File size: %ld bytes&quot;, size); else snprintf(response, sizeof(response), &quot;Error: cannot open file&quot;); send(new_socket, response, strlen(response), 0); close(new_socket); }} rpc_client.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#define PORT 8081#define BUFFER_SIZE 1024int main() { int sock = 0; struct sockaddr_in serv_addr; char buffer[BUFFER_SIZE] = {0}; char filename[BUFFER_SIZE]; printf(&quot;Enter filename: &quot;); scanf(&quot;%s&quot;, filename); if ((sock = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) { perror(&quot;socket creation error&quot;); return -1; } serv_addr.sin_family = AF_INET; serv_addr.sin_port = htons(PORT); if (inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;serv_addr.sin_addr) &lt;= 0) { perror(&quot;Invalid address&quot;); return -1; } if (connect(sock, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)) &lt; 0) { perror(&quot;Connection failed&quot;); return -1; } send(sock, filename, strlen(filename), 0); read(sock, buffer, BUFFER_SIZE); printf(&quot;Response from server: %s\\n&quot;, buffer); close(sock); return 0;} 运行结果： （三）远程方法调用远程方法调用是面向对象编程下的 RPC，适用于分布式面向对象系统中远程对象的方法调用，如远程对象服务、分布式面向对象应用等场景。 应用场景：在分布式电商系统中，客户端应用（如手机购物 APP 的后端进程）需要调用远程订单服务器上 “创建订单” 的对象方法：客户端进程持有远程订单对象的引用，调用该对象的create_order(user_id, goods_list)方法；客户端存根将方法名（create_order）、参数（用户 ID、商品列表）打包为消息并发送给订单服务器；服务器端的服务器存根接收消息，解析后调用订单对象的实际create_order方法，生成订单并返回订单号；服务器存根将订单号打包为消息发送回客户端，客户端存根解析消息并将订单号返回给客户端进程，整个过程符合面向对象编程范式，对客户端程序员透明。 面向对象场景下的远程方法调用代码：rmi_server.cpp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;time.h&gt;#define PORT 8082#define BUFFER_SIZE 1024// 模拟远程对象方法：创建订单void create_order(const char *user, const char *goods, char *order_id) { srand(time(NULL)); int num = rand() % 10000; snprintf(order_id, BUFFER_SIZE, &quot;ORDER-%s-%s-%d&quot;, user, goods, num);}int main() { int server_fd, new_socket; struct sockaddr_in address; int addrlen = sizeof(address); char buffer[BUFFER_SIZE] = {0}; if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) { perror(&quot;socket failed&quot;); exit(EXIT_FAILURE); } address.sin_family = AF_INET; address.sin_addr.s_addr = INADDR_ANY; address.sin_port = htons(PORT); if (bind(server_fd, (struct sockaddr *)&amp;address, sizeof(address)) &lt; 0) { perror(&quot;bind failed&quot;); exit(EXIT_FAILURE); } if (listen(server_fd, 3) &lt; 0) { perror(&quot;listen&quot;); exit(EXIT_FAILURE); } printf(&quot;RMI Server running on port %d...\\n&quot;, PORT); while (1) { if ((new_socket = accept(server_fd, (struct sockaddr *)&amp;address, (socklen_t*)&amp;addrlen)) &lt; 0) { perror(&quot;accept&quot;); exit(EXIT_FAILURE); } memset(buffer, 0, BUFFER_SIZE); read(new_socket, buffer, BUFFER_SIZE); printf(&quot;Server received request: %s\\n&quot;, buffer); // 解析输入：user goods char user[50], goods[50]; sscanf(buffer, &quot;%s %s&quot;, user, goods); char order_id[BUFFER_SIZE]; create_order(user, goods, order_id); send(new_socket, order_id, strlen(order_id), 0); close(new_socket); }} rmi_client.cpp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#define PORT 8082#define BUFFER_SIZE 1024int main() { int sock = 0; struct sockaddr_in serv_addr; char buffer[BUFFER_SIZE] = {0}; char user[50], goods[50]; printf(&quot;Enter user ID: &quot;); scanf(&quot;%s&quot;, user); printf(&quot;Enter goods: &quot;); scanf(&quot;%s&quot;, goods); if ((sock = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) { perror(&quot;socket creation error&quot;); return -1; } serv_addr.sin_family = AF_INET; serv_addr.sin_port = htons(PORT); if (inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;serv_addr.sin_addr) &lt;= 0) { perror(&quot;Invalid address&quot;); return -1; } if (connect(sock, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)) &lt; 0) { perror(&quot;Connection failed&quot;); return -1; } char request[BUFFER_SIZE]; snprintf(request, sizeof(request), &quot;%s %s&quot;, user, goods); send(sock, request, strlen(request), 0); read(sock, buffer, BUFFER_SIZE); printf(&quot;Order created with ID: %s\\n&quot;, buffer); close(sock); return 0;} 运行结果：","link":"/2025/09/17/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"}],"tags":[{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"OS","slug":"OS","link":"/tags/OS/"}],"categories":[],"pages":[]}